<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>POLYGON BONSAI / Ikebana Style</title>
    <style>
        /* =======================================================================
   GEOMETRIC BONSAI — Unified Design System (Techno Minimal)
   - Hue-driven accent themes
   - Light/Dark mode aware
   - Role-based component styling
   ======================================================================= */

        /* -----------------------------------------------------------------------------
   1) PRIMITIVES (mode-agnostic)
   ----------------------------------------------------------------------------- */
        :root {
            /* Typography & layout */
            --font-sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
            --font-mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;

            --panel-w: 380px;
            --r-1: 6px;
            --r-2: 8px;
            --r-3: 10px;
            --s-1: .35rem;
            --s-2: .6rem;
            --s-3: .7rem;
            --s-4: .75rem;
            --s-5: 1rem;

            /* Fallback neutrals (will be mapped by mode) */
            --surface-0-base: #0e1115;
            /* canvas */
            --surface-1-base: #0f141a;
            /* panel */
            --surface-2-base: #141a22;
            /* controls */

            /* Lines (base) */
            --c-line: rgba(255, 255, 255, .08);
            --c-line-strong: rgba(255, 255, 255, .12);

            /* Accent ramp (will be overridden by [data-accent]) */
            --accent-100: #e4fff8;
            --accent-200: #cafff1;
            --accent-300: #a7ffe9;
            --accent-400: #5df0c9;
            --accent-500: #38ffd8;
            --accent-600: #1ce3bf;
            --accent-700: #12b69b;
            --accent-800: #0b8d78;
            --accent-900: #0a6d5d;


            /* Interaction timing */
            --t-fast: 120ms;
            --t-med: 220ms;
            --t-slow: 360ms;
            --e-out: cubic-bezier(.17, .67, .2, 1);
            --e-in: cubic-bezier(.4, 0, .7, .2);

            /* On-accent text (set precisely by JS; fallback to near-black) */
            --text-on-accent: #0b0f12;

            /* Z */
            --z-stage: 1;
            --z-hud: 10;
        }

        /* -----------------------------------------------------------------------------
   2) ACCENT FAMILIES (hue groups) — set via #app[data-accent="..."]
   ----------------------------------------------------------------------------- */
        /* Cyan */
        #app[data-accent="cyan"] {
            --accent-100: #e4fff8;
            --accent-200: #cafff1;
            --accent-300: #a7ffe9;
            --accent-400: #5df0c9;
            --accent-500: #38ffd8;
            --accent-600: #1ce3bf;
            --accent-700: #12b69b;
            --accent-800: #0b8d78;
            --accent-900: #0a6d5d;
            --accent-on: #021a16;
        }

        /* Magenta */
        #app[data-accent="magenta"] {
            --accent-100: #fff1fb;
            --accent-200: #ffd5f5;
            --accent-300: #ffc4f6;
            --accent-400: #ff86f0;
            --accent-500: #ff5bea;
            --accent-600: #e544d1;
            --accent-700: #c22eb1;
            --accent-800: #97238a;
            --accent-900: #701a67;
            --accent-on: #180616;
        }

        /* Amber */
        #app[data-accent="amber"] {
            --accent-100: #fff9e6;
            --accent-200: #fff1cc;
            --accent-300: #ffe8a1;
            --accent-400: #ffd46a;
            --accent-500: #ffcc4d;
            --accent-600: #f2b83a;
            --accent-700: #d19a25;
            --accent-800: #a9791a;
            --accent-900: #7f5914;
            --accent-on: #0f0b02;
        }

        /* Lime */
        #app[data-accent="lime"] {
            --accent-100: #f3ffe3;
            --accent-200: #e7ffc8;
            --accent-300: #e9ffc8;
            --accent-400: #cdfb89;
            --accent-500: #b7ff64;
            --accent-600: #9deb49;
            --accent-700: #79c52e;
            --accent-800: #5a9a23;
            --accent-900: #3f6f19;
            --accent-on: #0b1304;
        }

        /* Black (Monochrome high-contrast) */
        #app[data-accent="black"] {
            --accent-100: #f5f5f5;
            --accent-200: #e0e0e0;
            --accent-300: #c2c2c2;
            --accent-400: #9e9e9e;
            --accent-500: #757575;
            --accent-600: #555555;
            --accent-700: #333333;
            --accent-800: #1f1f1f;
            --accent-900: #000000;
            --accent-on: #ffffff;
        }

        /* White (inverse monochrome) */
        #app[data-accent="white"] {
            --accent-100: #ffffff;
            --accent-200: #fafafa;
            --accent-300: #f5f5f5;
            --accent-400: #e0e0e0;
            --accent-500: #cccccc;
            --accent-600: #aaaaaa;
            --accent-700: #888888;
            --accent-800: #555555;
            --accent-900: #222222;
            --accent-on: #0b0f12;
        }

        /* -----------------------------------------------------------------------------
   3) MODE MAPS (dark/light) — surfaces, borders, text roles
   ----------------------------------------------------------------------------- */
        /* DARK */
        #app[data-mode="dark"] {
            /* Surfaces (subtle accent tint) */
            --surface-0: color-mix(in oklab, var(--surface-0-base) 94%, var(--accent-900));
            --surface-1: color-mix(in oklab, var(--surface-1-base) 94%, var(--accent-900));
            --surface-2: color-mix(in oklab, var(--surface-2-base) 96%, var(--accent-900));

            /* Borders */
            --outline: color-mix(in oklab, var(--accent-600) 14%, var(--surface-1));
            --outline-strong: color-mix(in oklab, var(--accent-600) 22%, var(--surface-1));

            /* Text by surface */
            --text-on-surface-0: color-mix(in oklab, var(--accent-100) 88%, transparent);
            --text-on-surface-1: color-mix(in oklab, var(--accent-100) 84%, transparent);
            --text-on-surface-2: color-mix(in oklab, var(--accent-100) 92%, transparent);

            /* Accent-tinted text choices (use light end for dark mode) */
            --text-accent-strong: var(--accent-300);
            --text-accent: var(--accent-200);
            --text-accent-muted: color-mix(in oklab, var(--accent-200) 70%, var(--text-on-surface-1));

            /* Role aliases used by UI */
            --text-strong: var(--text-on-surface-2);
            --text-heading: var(--text-accent-strong);
            --text-subtle: var(--text-accent);
            --text-dim: var(--text-accent-muted);

            /* HUD */
            --hud-border: 1px solid color-mix(in oklab, var(--accent-500) 35%, transparent);
            --hud-bg: linear-gradient(180deg,
                    color-mix(in oklab, var(--surface-1) 76%, transparent),
                    color-mix(in oklab, var(--surface-1) 56%, transparent));
            --hud-text: var(--accent-200);
            --hud-key: var(--accent-300);

            /* Controls */
            --ctl-bg: color-mix(in oklab, var(--surface-2) 92%, black 8%);
            --ctl-bg-hover: color-mix(in oklab, var(--surface-2) 88%, var(--accent-700) 12%);
            --ctl-bg-active: color-mix(in oklab, var(--surface-2) 84%, var(--accent-700) 16%);
            --ctl-bd: 1px solid color-mix(in oklab, var(--accent-600) 22%, var(--outline-strong));
            --ctl-bd-hover: 1px solid color-mix(in oklab, var(--accent-600) 42%, var(--outline-strong));
            --ctl-bd-active: 1px solid color-mix(in oklab, var(--accent-600) 55%, var(--outline-strong));

            /* Text inside controls */
            --text-on-control: var(--text-on-surface-2);

            /* Primary buttons */
            --btn-primary-bg: linear-gradient(180deg, var(--accent-600), var(--accent-700));
            --btn-primary-border: 1px solid var(--accent-700);
            --btn-primary-text: var(--accent-on);

            --glow-outer: 0 0 12px color-mix(in oklab, var(--accent-500) 16%, transparent);
            --glow-inner: inset 0 0 12px color-mix(in oklab, var(--accent-500) 8%, transparent);
            --focus-ring: 0 0 0 2px color-mix(in oklab, var(--accent-500) 28%, transparent);
            --blur: 3px;
        }

        /* LIGHT */
        #app[data-mode="light"] {
            /* Base neutrals */
            --surface-0-base: #f6f8fb;
            --surface-1-base: #eef2f7;
            --surface-2-base: #e7edf5;

            /* Surfaces (subtle accent tint) */
            --surface-0: color-mix(in oklab, var(--surface-0-base) 96%, var(--accent-200));
            --surface-1: color-mix(in oklab, var(--surface-1-base) 96%, var(--accent-200));
            --surface-2: color-mix(in oklab, var(--surface-2-base) 96%, var(--accent-200));

            /* Borders */
            --outline: color-mix(in oklab, var(--accent-700) 16%, #b7c4d6);
            --outline-strong: color-mix(in oklab, var(--accent-700) 26%, #a5b4c8);

            /* Text on each surface */
            --text-on-surface-0: color-mix(in oklab, var(--accent-900) 90%, transparent);
            --text-on-surface-1: color-mix(in oklab, var(--accent-900) 86%, transparent);
            --text-on-surface-2: color-mix(in oklab, var(--accent-900) 92%, transparent);

            /* Accent-tinted text choices (use dark end for light mode) */
            --text-accent-strong: var(--accent-800);
            --text-accent: var(--accent-700);
            --text-accent-muted: color-mix(in oklab, var(--accent-700) 65%, var(--text-on-surface-1));

            /* Role aliases used by UI */
            --text-strong: var(--text-on-surface-2);
            --text-heading: var(--text-accent-strong);
            --text-subtle: var(--text-accent);
            --text-dim: var(--text-accent-muted);

            /* HUD */
            --hud-border: 1px solid color-mix(in oklab, var(--accent-600) 40%, transparent);
            --hud-bg: linear-gradient(180deg,
                    color-mix(in oklab, var(--surface-1) 88%, transparent),
                    color-mix(in oklab, var(--surface-1) 70%, transparent));
            --hud-text: var(--accent-800);
            --hud-key: var(--accent-700);

            /* Controls */
            --ctl-bg: color-mix(in oklab, var(--surface-2) 96%, white 4%);
            --ctl-bg-hover: color-mix(in oklab, var(--surface-2) 92%, var(--accent-400) 12%);
            --ctl-bg-active: color-mix(in oklab, var(--surface-2) 88%, var(--accent-400) 18%);
            --ctl-bd: 1px solid color-mix(in oklab, var(--accent-600) 26%, var(--outline-strong));
            --ctl-bd-hover: 1px solid color-mix(in oklab, var(--accent-600) 42%, var(--outline-strong));
            --ctl-bd-active: 1px solid color-mix(in oklab, var(--accent-600) 55%, var(--outline-strong));

            /* Text inside controls */
            --text-on-control: var(--text-on-surface-2);

            /* Primary buttons */
            --btn-primary-bg: linear-gradient(180deg, var(--accent-600), var(--accent-700));
            --btn-primary-border: 1px solid var(--accent-700);
            --btn-primary-text: var(--accent-on);

            --glow-outer: 0 0 12px color-mix(in oklab, var(--accent-900) 16%, transparent);
            --glow-inner: inset 0 0 12px color-mix(in oklab, var(--accent-900) 8%, transparent);
            --focus-ring: 0 0 0 2px color-mix(in oklab, var(--accent-900) 28%, transparent);
            --blur: 3px;
        }

        /* -----------------------------------------------------------------------------
   4) GLOBAL BASE / LAYOUT
   ----------------------------------------------------------------------------- */
        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--surface-0);
            color: var(--text-on-surface-0);
            font-family: var(--font-mono);
        }

        #app {
            position: fixed;
            inset: 0;
            display: grid;
            grid-template-columns: var(--panel-w) 1fr;
            grid-template-rows: auto 1fr;
            grid-template-areas:
                "header header"
                "panel stage";
            background: var(--surface-0);
            color: var(--text-on-surface-0);
        }

        /* -----------------------------------------------------------------------------
   5) HEADER
   ----------------------------------------------------------------------------- */
        header {
            grid-area: header;
            display: flex;
            align-items: center;
            gap: var(--s-4);
            padding: .65rem var(--s-5);
            background: linear-gradient(180deg,
                    color-mix(in oklab, var(--surface-1) 96%, transparent),
                    transparent);
            border-bottom: 1px solid var(--outline);
        }

        header h1 {
            font-size: 1rem;
            letter-spacing: .06em;
            margin: 0;
            color: var(--hud-key);
            font-weight: 600;
        }

        /* Right-side header tools (theme selectors, etc.) */
        header .header-tools {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: .5rem;
        }

        /* -----------------------------------------------------------------------------
   6) PANEL (side)
   ----------------------------------------------------------------------------- */
        #panel {
            grid-area: panel;
            overflow: auto;
            background: var(--surface-1);
            box-shadow: inset -1px 0 0 var(--outline);
            padding: 16px;
            box-sizing: border-box;
        }

        /* Section */
        .section {
            margin-bottom: 14px;
            border: 1px solid var(--outline);
            border-radius: var(--r-3);
            background: var(--surface-1);
            box-shadow: var(--glow-outer), var(--glow-inner);
        }

        .section>h2 {
            margin: 0;
            font-size: .9rem;
            padding: .55rem var(--s-3);
            color: var(--hud-key);
            border-bottom: 1px dashed var(--outline);
            letter-spacing: .03em;
        }

        /* Form grid */
        .form {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px 10px;
            align-items: center;
            padding: var(--s-2) var(--s-3);
        }

        .full {
            grid-column: 1 / -1;
        }

        .row {
            display: flex;
            flex-wrap: wrap;
            gap: .4rem;
            align-items: center;
        }

        .form label,
        .section label,
        label {
            color: var(--text-subtle);
        }

        /* -----------------------------------------------------------------------------
   7) SHARED CONTROL BASE (inputs/buttons/selects)
   ----------------------------------------------------------------------------- */
        .control,
        select,
        input[type="text"],
        input[type="number"],
        input[type="color"],
        input[type="range"],
        .button,
        .btn {
            width: 100%;
            box-sizing: border-box;
            background: var(--surface-2);
            color: var(--text-on-surface-2);
            border: 1px solid var(--outline-strong);
            border-radius: var(--r-2);
            transition: background var(--t-med) var(--e-out),
                border-color var(--t-med) var(--e-out),
                box-shadow var(--t-med) var(--e-out),
                transform var(--t-fast) var(--e-out);
            box-shadow: 0 1px 0 rgba(255, 255, 255, .04), inset 0 1px 0 rgba(255, 255, 255, .03);
        }

        .control:hover,
        select:hover,
        input[type="text"]:hover,
        input[type="number"]:hover,
        input[type="color"]:hover,
        .button:hover,
        .btn:hover {
            border-color: color-mix(in oklab, var(--accent-600) 42%, var(--outline-strong));
        }

        .control:active,
        select:active,
        input[type="text"]:active,
        input[type="number"]:active,
        input[type="color"]:active,
        .button:active,
        .btn:active {
            transform: translateY(.5px);
        }

        .control:focus-visible,
        select:focus-visible,
        input[type="text"]:focus-visible,
        input[type="number"]:focus-visible,
        input[type="color"]:focus-visible,
        input[type="range"]:focus-visible,
        .button:focus-visible,
        .btn:focus-visible {
            outline: none;
            box-shadow: var(--focus-ring);
        }

        /* Select */
        select {
            padding: .45rem .6rem;
        }

        /* Text/number */
        input[type="text"],
        input[type="number"] {
            padding: .45rem .6rem;
        }

        /* Color */
        input[type="color"] {
            padding: .2rem;
        }

        /* Buttons */
        .btn,
        .button {
            padding: .55rem var(--s-3);
            font-weight: 700;
            cursor: pointer;
            user-select: none;
        }

        /* Button variants */
        .btn-primary {
            background: var(--accent-600);
            border: 1px solid color-mix(in oklab, var(--accent-700) 60%, var(--accent-500));
            color: var(--btn-primary-text);
        }

        .btn-primary:hover {
            background: var(--accent-500);
            color: var(--text-on-accent);
        }

        .btn-primary:active {
            background: var(--accent-700);
            color: var(--text-on-accent);
        }

        .btn-ghost {
            background: transparent;
            border: 1px dashed color-mix(in oklab, var(--accent-600) 45%, var(--outline));
            color: var(--hud-key);
        }

        .btn-ghost:hover {
            background: color-mix(in oklab, var(--accent-600) 12%, transparent);
        }

        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            display: grid;
            place-items: center;
        }

        /* -----------------------------------------------------------------------------
   8) RANGE SLIDER
   ----------------------------------------------------------------------------- */
        input[type="range"] {
            height: 28px;
            width: 100%;
            padding: 0;
            background: transparent;
            border: none;
            box-shadow: none !important;
            -webkit-appearance: none;
            appearance: none;
            /* prevent UA accent fill */
        }

        input[type="range"]::-webkit-slider-runnable-track {
            height: 6px;
            background: linear-gradient(90deg, var(--accent-700), var(--accent-500));
            border-radius: 999px;
            border: none;
            box-shadow: inset 0 0 0 1px color-mix(in oklab, var(--accent-600) 40%, var(--outline-strong));
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-200);
            border: 2px solid var(--accent-600);
            margin-top: -5px;
            /* align thumb to track */
            box-shadow: 0 0 8px color-mix(in oklab, var(--accent-500) 50%, transparent);
            transition: transform var(--t-fast) var(--e-out), box-shadow var(--t-med) var(--e-out);
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.06);
            box-shadow: 0 0 14px color-mix(in oklab, var(--accent-500) 70%, transparent);
        }

        /* ===== Firefox track/thumb/progress ===== */
        /* In FF, the "progress" (before-thumb) is a separate layer; give both same look to avoid double coloring */
        input[type="range"]::-moz-range-track,
        input[type="range"]::-moz-range-progress {
            height: 6px;
            border-radius: 999px;
            background: linear-gradient(90deg, var(--accent-700), var(--accent-500));
            border: 1px solid color-mix(in oklab, var(--accent-600) 40%, var(--c-line-strong));
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-200);
            border: 2px solid var(--accent-600);
            box-shadow: 0 0 8px color-mix(in oklab, var(--accent-500) 50%, transparent);
        }


        /* -----------------------------------------------------------------------------
   9) SWITCH / TOGGLE
   ----------------------------------------------------------------------------- */
        .switch {
            --sw-w: 42px;
            --sw-h: 24px;
            position: relative;
            display: inline-block;
            width: var(--sw-w);
            height: var(--sw-h);
            background: var(--surface-2);
            border: 1px solid var(--outline-strong);
            border-radius: 999px;
            cursor: pointer;
            transition: background var(--t-med) var(--e-out), border-color var(--t-med) var(--e-out);
        }

        .switch input {
            display: none;
        }

        .switch .knob {
            position: absolute;
            top: 2px;
            left: 2px;
            width: calc(var(--sw-h) - 4px);
            height: calc(var(--sw-h) - 4px);
            background: var(--accent-200);
            border-radius: 50%;
            box-shadow: 0 0 8px color-mix(in oklab, var(--accent-500) 50%, transparent);
            transition: transform var(--t-med) var(--e-out), box-shadow var(--t-med) var(--e-out);
        }

        .switch input:checked+.knob {
            transform: translateX(calc(var(--sw-w) - var(--sw-h)));
            background: var(--accent-100);
            box-shadow: 0 0 14px color-mix(in oklab, var(--accent-500) 70%, transparent);
        }

        /* -----------------------------------------------------------------------------
   10) SEGMENTED CONTROL
   ----------------------------------------------------------------------------- */
        .segmented {
            display: inline-grid;
            grid-auto-flow: column;
            gap: 6px;
            padding: 6px;
            border-radius: var(--r-3);
            background: color-mix(in oklab, var(--surface-2) 85%, var(--accent-900));
            border: 1px solid color-mix(in oklab, var(--accent-600) 25%, var(--outline-strong));
        }

        .segmented .seg {
            padding: .35rem .6rem;
            border-radius: var(--r-2);
            background: transparent;
            color: var(--hud-key);
            border: 1px dashed color-mix(in oklab, var(--accent-600) 35%, var(--outline));
            cursor: pointer;
            user-select: none;
            transition: background var(--t-med) var(--e-out), border-color var(--t-med) var(--e-out);
        }

        .segmented .seg[aria-pressed="true"],
        .segmented .seg.is-active {
            background: color-mix(in oklab, var(--accent-600) 40%, var(--surface-1) 60%);
            border: 1px solid color-mix(in oklab, var(--accent-600) 60%, var(--outline-strong));
            color: var(--text-on-accent);
        }

        /* -----------------------------------------------------------------------------
   11) STAGE
   ----------------------------------------------------------------------------- */
        #stageWrap {
            grid-area: stage;
            position: relative;
        }

        #bgOverlay {
            position: absolute;
            inset: 0;
            z-index: 0;
        }

        #stage {
            position: absolute;
            inset: 0;
            z-index: var(--z-stage);
        }

        /* -----------------------------------------------------------------------------
   12) FOOTER / TIP BAR
   ----------------------------------------------------------------------------- */
        /* Tips bar now below header, not floating */
        /* Tips bar pinned at the top of the canvas (inside #stageWrap) */
        #tipsBar {
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--s-3);
            padding: .4rem .6rem;
            color: var(--text-subtle);
            font-size: .85rem;
            background: linear-gradient(180deg,
                    color-mix(in oklab, var(--surface-1) 65%, transparent),
                    color-mix(in oklab, var(--surface-1) 40%, transparent));
            border: 1px solid var(--outline);
            border-radius: var(--r-3);
            box-shadow: var(--glow-outer);
            z-index: var(--z-hud);
            /* above canvas, below panel */
            max-width: calc(100% - 24px);
            /* stay inside canvas on phones */
            pointer-events: auto;
            /* clickable */
        }


        .kbd {
            background: var(--surface-1);
            border: 1px solid color-mix(in oklab, var(--accent-600) 30%, var(--outline-strong));
            color: var(--hud-key);
            padding: .15rem .35rem;
            border-radius: var(--r-1);
            font-size: .85em;
        }

        /* -----------------------------------------------------------------------------
   13) HUD (adaptive position — aligns to panel width)
   ----------------------------------------------------------------------------- */
        #hud {
            position: absolute;
            top: 82px;
            left: calc(var(--panel-w) + 16px);
            max-width: 360px;
            max-height: 60vh;
            overflow: auto;
            padding: 10px 12px;
            border: var(--hud-border);
            background: var(--hud-bg);
            box-shadow: var(--glow-outer), var(--glow-inner);
            border-radius: var(--r-2);
            font: 12px/1.35 var(--font-mono);
            color: var(--hud-text);
            letter-spacing: .2px;
            backdrop-filter: blur(var(--blur));
            display: none;
            /* toggle via JS */
            z-index: var(--z-hud);
        }

        #hud .hdr {
            color: var(--hud-key);
            text-transform: uppercase;
            font-weight: 700;
            margin: 8px 0 4px;
            border-bottom: 1px dashed color-mix(in oklab, var(--accent-500) 35%, transparent);
            padding-bottom: 2px;
        }

        #hud .k {
            color: var(--hud-key);
        }

        #hud .v {
            color: color-mix(in oklab, var(--text-on-surface-1) 92%, var(--accent-200) 8%);
        }

        #hud .warn {
            color: #ffde69;
        }

        #hud .err {
            color: #ff8a8a;
        }

        /* -----------------------------------------------------------------------------
   14) SCROLLBARS (global, accent-tinted)
   ----------------------------------------------------------------------------- */
        * {
            scrollbar-width: thin;
            scrollbar-color: color-mix(in oklab, var(--accent-700) 25%, var(--surface-2)) var(--surface-1);
        }

        *::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        *::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--accent-700), var(--accent-500));
            border-radius: var(--r-2);
            border: 2px solid var(--surface-1);
            box-shadow: var(--glow-inner);
        }

        /* -----------------------------------------------------------------------------
   15) ACCESSIBILITY & MOTION
   ----------------------------------------------------------------------------- */
        *:focus-visible {
            outline: none;
            box-shadow: var(--focus-ring);
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                transition: none !important;
                animation: none !important;
            }
        }

        /* === Floating Canvas Toolbar === */
        #canvasToolbar {
            position: absolute;
            bottom: 12px;
            /* bottom will be set dynamically so it sits above the footer (see JS) */
            left: 50%;
            transform: translateX(-50%);
            display: grid;
            grid-auto-flow: column;
            min-width: 260px;
            justify-content: center;
            align-items: center;
            gap: 6px;
            padding: 6px 8px;
            background: var(--hud-bg);
            border: var(--hud-border);
            border-radius: var(--r-2);
            box-shadow: var(--glow-outer), var(--glow-inner);
            z-index: var(--z-hud);
            backdrop-filter: blur(var(--blur));
            max-width: calc(100% - 24px);
            /* keep inside canvas on mobile */
        }

        #canvasToolbar .split {
            width: 1px;
            height: 20px;
            background: color-mix(in oklab, var(--accent-600) 30%, transparent);
            margin: 0 2px;
            border-radius: 1px;
        }

        #canvasToolbar .btn.btn-icon {
            width: 34px;
            height: 34px;
            font-weight: 700;
            padding: 0;
        }


        /* === Collapsible Panel (desktop & mobile) === */
        /* When collapsed, hide the left column (settings panel) and expand the stage */
        #app.panel-hidden {
            grid-template-columns: 0 1fr;
        }

        #app.panel-hidden #panel {
            display: none;
        }

        /* When panel is hidden, shift HUD closer to the left edge */
        #app.panel-hidden #hud {
            left: 16px;
        }

        @media (max-width: 900px) {

            /* Single-column stack:
     - Header on top
     - Stage (canvas) next
     - Panel (settings) at the bottom (scrollable) */
            #app {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto;
                /* header / stage / panel */
                grid-template-areas:
                    "header"
                    "stage"
                    "panel";
            }

            /* Stage fills available height */
            #stageWrap {
                min-height: 56vh;
                /* canvas still tall enough on phones */
                position: relative;
                z-index: 1;
                /* lower than #panel */

            }

            /* Renderer canvas should never bleed over into the panel area */
            #stage {
                position: absolute;
                inset: 0;
                z-index: var(--z-stage);
                /* already set, keep it within its row's stacking context */
            }

            /* Panel is visible by default, scrollable within its own area */
            #panel {
                position: relative;
                z-index: 5;
                display: block;
                max-height: 44vh;
                /* you can tweak; lets both canvas+panel be visible */
                overflow: auto;
                border-top: 1px solid var(--outline);
                box-shadow: none;
                /* avoid heavy shadows on small screens */
            }

            /* When the class is present, THEN hide the panel (hamburger toggles this) */
            #app.panel-hidden {
                grid-template-columns: 1fr !important;
                grid-template-areas:
                    "header"
                    "stage";
            }

            #app.panel-hidden #panel {
                display: none !important;
            }
        }

        /* HUD becomes a normal block inside the panel (no absolute overlay) */
        #hud {
            position: static;
            max-width: none;
            max-height: none;
            left: auto;
            top: auto;
            margin-top: 8px;
        }

        /* Toolbar: keep centered above footer with our JS bottom-offset */
        #canvasToolbar {
            left: 50%;
            transform: translateX(-50%);
            max-width: calc(100% - 24px);
        }

        /* On phones, show HUD as a normal section (no absolute overlay) */
        #hud {
            position: static;
            max-width: none;
            max-height: none;
            left: auto;
            top: auto;
            margin-top: 8px;
        }

        #hud .hdr {
            margin: 6px 0 4px;
        }

        }
    </style>

    <!-- Import map for bare specifier "three" -->
    <script type="importmap">
  { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
  </script>
</head>

<body>
    <div id="app" data-mode="light" data-accent="cyan">
        <header>
            <button id="panelToggle" class="btn btn-icon" aria-pressed="false" title="Toggle settings">☰</button>
            <h1>POLYGON BONSAI</h1>
            <div class="header-tools">
                <!-- Accent theme dropdown -->
                <label for="themeSelect" class="theme-label">THEME</label>
                <select id="themeSelect" class="theme-dropdown" aria-label="Accent theme">
                    <option value="cyan">Cyan</option>
                    <option value="magenta">Magenta</option>
                    <option value="amber">Amber</option>
                    <option value="lime">Lime</option>
                    <option value="black">Black</option>
                    <option value="white">White</option>
                </select>
                <!-- Mode segmented control -->
                <div id="modeControl" class="segmented" role="group" aria-label="Color scheme">
                    <button type="button" class="seg" data-mode="dark" aria-pressed="false">Dark</button>
                    <button type="button" class="seg" data-mode="light" aria-pressed="true">Light</button>
                </div>
            </div>
        </header>
        <aside id="panel">
            <div class="section">
                <h2>SCENE</h2> <!-- Debug HUD toggle -->
                <div class="form">
                    <!-- Cyberpunk HUD overlay -->
                    <label>Display Debug</label>
                    <input id="debugToggle" type="checkbox">
                    <div id="hud" aria-hidden="true"></div>
                    <label>Background</label>
                    <input id="bgColor" type="color" value="#0e1115" />
                    <label>Texture</label>
                    <select id="bgTex">
                        <option value="solid">Solid</option>
                        <option value="grain">Grain</option>
                        <option value="gradient">Gradient</option>
                        <option value="paper">Paper</option>
                    </select>
                    <label>Key</label>
                    <input id="keyLight" type="range" min="0" max="5" step="0.01" value="0.55" />
                    <label>Ambient</label>
                    <input id="hemiLight" type="range" min="0" max="5" step="0.01" value="0.9" />
                    <label>Exposure</label>
                    <input id="exposure" type="range" min="0.5" max="2.5" step="0.01" value="1" />
                    <div class="full row">
                        <button id="newSeed" class="btn">New Seed</button>
                        <span>Seed: <span id="seedLabel" class="kbd">—</span></span>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>SPECIES</h2>
                <div class="form">
                    <label>Type</label>
                    <select id="treeType">
                        <option value="magnolia">Magnolia (petals, arching)</option>
                        <option value="maple">Maple (broad, lobed)</option>
                        <option value="pine">Pine (upright, whorled)</option>
                        <option value="olive">Olive (compact, slabs)</option>
                        <option value="juniper">Juniper (windswept)</option>
                        <option value="ginkgo">Ginkgo (tiered fans)</option>
                    </select>
                    <!-- Phase C.1: Height & Leaf Size Controls -->
                    <label>Plant Height</label>

                    <div class="field">
                        <input id="heightScale" type="range" min="0.3" max="1.6" step="0.01" value="1.00" />
                        <span id="heightScale_val">1.00</span>
                    </div>
                    <label>Levels</label>
                    <input id="levels" type="range" min="3" max="10" step="1" value="6" />
                    <label>Curvature</label>
                    <input id="curvature" type="range" min="0" max="1" step="0.01" value="0.55" />
                    <label>Uniformity</label>
                    <input id="uniformity" type="range" min="0" max="1" step="0.01" value="0.6" />
                    <label>Spread</label>
                    <input id="spread" type="range" min="0.3" max="1.2" step="0.01" value="0.75" />
                    <label>Up-Bias</label>
                    <input id="upBias" type="range" min="0" max="1" step="0.01" value="0.3" />
                </div>
            </div>
            <div class="section">
                <h2>LEAVES</h2>
                <div class="form">
                    <label>Leaf Type</label>
                    <select id="leafType">
                        <option value="diamond">Diamond</option>
                        <option value="needle">Needle</option>
                        <option value="slab">Slab</option>
                        <option value="sphere">Sphere</option>
                        <option value="triangle">Triangle</option>
                        <option value="cone">Cone</option>
                        <option value="teardrop">Teardrop</option>
                        <option value="half">Half‑circle</option>
                        <option value="crescent">Crescent</option>
                        <option value="petal">Petal (flower)</option>
                    </select>
                    <label>Plumage</label>
                    <select id="plumage">
                        <option value="random">Random</option>
                        <option value="upward">Upward</option>
                        <option value="radial">Radial</option>
                        <option value="wind-left">Wind →</option>
                        <option value="wind-right">Wind ←</option>
                    </select>
                    <label>Leaf Color</label>
                    <input id="leafColor" type="color" value="#2d6e52">
                    <label>Per-level Min</label>
                    <input id="bMin" type="range" min="1" max="6" step="1" value="2" />
                    <label>Per-level Max</label>
                    <input id="bMax" type="range" min="1" max="8" step="1" value="3" />
                    <label>Terminal Density</label>
                    <input id="density" type="range" min="0.3" max="3" step="0.01" value="1" />
                    <label>Spread</label>
                    <input id="leafSpread" type="range" min="0.3" max="2.5" step="0.01" value="1" />
                    <div class="field">
                        <label>Size</label>
                        <input id="leafSize" type="range" min="0.4" max="2.0" step="0.01" value="1.00">
                        <span id="leafSize_val">1.00</span>
                    </div>

                    <div class="field">
                        <label>Variation (±%)</label>
                        <input id="leafVar" type="range" min="0" max="0.9" step="0.01" value="0.25">
                        <span id="leafVar_val">0.25</span>
                    </div>

                    <!-- Phase B: Leaf Allocation Controls -->
                    <div class="field">
                        <label>Max Leaves</label>
                        <input id="maxLeaves" type="range" min="100" max="1000" step="100" value="500">
                        <span id="maxLeaves_val">500</span>
                    </div>
                    <div class="field">
                        <label>Lower-Canopy Bias</label>
                        <input id="lowerBias" type="range" min="0" max="1" step="0.01" value="0.35">
                        <span id="lowerBias_val">0.35</span>
                    </div>
                    <div class="field">
                        <label>Per-Terminal Min</label>
                        <input id="minPerTerminal" type="number" min="0" max="99" step="1" value="2">
                    </div>
                    <div class="field">
                        <label>Per-Terminal Max</label>
                        <input id="maxPerTerminal" type="number" min="1" max="999" step="1" value="60">
                    </div>

                </div>
            </div>

            <div class="section">
                <h2>BRANCHES</h2>
                <div class="form">
                    <label>Branch Color</label>
                    <input id="branchColor" type="color" value="#3b2d44">

                    <label>Depth</label>
                    <input id="bDepth" type="range" min="1" max="4" step="1" value="3" />

                    <label>Branch Length</label>
                    <input id="bLen" type="range" min="0.5" max="1.8" step="0.01" value="1" />

                    <!-- Phase C: Branch Attachment Controls -->
                    <div class="field">
                        <label>Branch Start Height</label>
                        <input id="branchStart" type="range" min="0" max="1" step="0.01" value="0.15">
                        <span id="branchStart_val">0.15</span>
                    </div>

                    <div class="field">
                        <label>Lower-Branch Bias (attachments)</label>
                        <input id="branchBias" type="range" min="0" max="1" step="0.01" value="0.45">
                        <span id="branchBias_val">0.45</span>
                    </div>
                    <!-- Phase D: Branch Length Variance & Falloff -->
                    <div class="field">
                        <label>Branch Length Variation (±%)</label>
                        <input id="bLenVar" type="range" min="0" max="0.9" step="0.01" value="0.25">
                        <span id="bLenVar_val">0.25</span>
                    </div>

                    <div class="field">
                        <label>Branch Falloff per Depth</label>
                        <input id="bFall" type="range" min="0.60" max="0.98" step="0.005" value="0.85">
                        <span id="bFall_val">0.85</span>
                    </div>

                </div>

            </div>

            <div class="section">
                <h2>VESSEL</h2>
                <div class="form">
                    <label>Color</label>
                    <input id="vesselColor" type="color" value="#a5b2bd" />
                    <label>Type</label>
                    <select id="vesselType">
                        <option value="glass-cylinder">Glass Cylinder</option>
                        <option value="shallow-bowl">Shallow Bowl</option>
                        <option value="faceted">Faceted Prism</option>
                        <option value="stone-disc">Stone Disc</option>
                    </select>
                    <label>Diameter</label>
                    <input id="vesselDia" type="range" min="0.8" max="2.4" step="0.01" value="1.2" />
                    <label>Depth</label>
                    <input id="vesselDepth" type="range" min="0.2" max="2.5" step="0.01" value="1.6" />
                </div>
            </div>

            <div class="section">
                <h2>RENDER + APPEARANCE</h2>
                <div class="form">
                    <button id="autoBtn" class="btn">⏸ Pause</button>
                    <input id="autoSpeed" type="range" min="-4" max="4" step="0.01" value="0.8" />
                    <label>Wireframe</label>
                    <select id="wireToggle">
                        <option value="off">Off</option>
                        <option value="on">On</option>
                    </select>
                    <label>Render Mode</label>
                    <select id="renderMode">
                        <option value="toon">Toon</option>
                        <option value="sketchy">Sketchy</option>
                        <option value="metallic">Metallic</option>
                        <option value="holographic">Holographic</option>
                        <option value="emissive">Emissive</option>
                    </select>
                    <label>Emissive Color</label>
                    <input id="emissiveColor" type="color" value="#94e3ff">
                    <label>Emissive Strength</label>
                    <input id="emissiveStrength" type="range" min="0" max="1" step="0.01" value="0.5" />
                </div>

            </div>
        </aside>

        <div id="stageWrap">
            <div id="bgOverlay"></div>
            <div id="stage"></div>
            <div id="tipsBar" role="note">
                <div>Tip: drag to orbit · wheel/pinch to zoom</div>
                <div>Press <span class="kbd">Frame</span> to refit</div>
            </div>
            <!-- Floating canvas toolbar -->
            <div id="canvasToolbar" role="toolbar" aria-label="Canvas tools">
                <button id="tbFrame" class="btn btn-icon" title="Frame (F)">⤢</button>
                <button id="tbWire" class="btn btn-icon" title="Wireframe (W)">◧</button>
                <span class="split"></span>
                <button id="tbSpinL" class="btn btn-icon" title="Rotate Left ([)">⟲</button>
                <button id="tbSlower" class="btn btn-icon" title="Slower">−</button>
                <button id="tbAuto" class="btn btn-icon" title="Play/Pause (Space)">⏸</button>
                <button id="tbFaster" class="btn btn-icon" title="Faster">＋</button>
                <button id="tbSpinR" class="btn btn-icon" title="Rotate Right (])">⟳</button>
                <span class="split"></span>
                <button id="tbShot" class="btn btn-icon" title="Screenshot (X)">📸</button>
                <button id="tbHelp" class="btn btn-icon" title="Toggle Tip Bar (H)">?</button>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

        // --- UI refs ---
        const $ = (id) => document.getElementById(id);
        const stage = $('stage');
        const bgOverlay = $('bgOverlay');
        const seedLabel = $('seedLabel');
        const treeType = $('treeType');
        const levels = $('levels');
        const curvature = $('curvature');
        const uniformity = $('uniformity');
        const spread = $('spread');
        const upBias = $('upBias');
        const bDepth = $('bDepth');
        const bMin = $('bMin');
        const bMax = $('bMax');
        const bLen = $('bLen');
        const density = $('density');
        const leafSpread = $('leafSpread');
        const leafType = $('leafType');
        const plumage = $('plumage');
        const vesselType = $('vesselType');
        const vesselDia = $('vesselDia');
        const vesselDepth = $('vesselDepth');
        const vesselColor = $('vesselColor');
        const bgColor = $('bgColor');
        const bgTex = $('bgTex');
        const keyLightUI = $('keyLight');
        const hemiLightUI = $('hemiLight');
        const exposureUI = $('exposure');
        const shotBtn = $('shot');
        const newSeedBtn = $('newSeed');
        const wireToggle = $('wireToggle');
        const renderMode = $('renderMode');
        const emissiveStrengthUI = document.getElementById('emissiveStrength');
        const autoBtn = document.getElementById('autoBtn');
        const autoRotate = $('autoRotate');
        const autoSpeedUI = $('autoSpeed');
        const branchColorUI = $('branchColor');
        const leafColorUI = $('leafColor');
        const emissiveColorUI = $('emissiveColor');
        [branchColorUI, leafColorUI, emissiveColorUI].forEach(el => el && el.addEventListener('input', applyRenderStyle));

        const MAX_GLOBAL_LEAVES = 1000;   // safety cap
        // ---- SAFETY CAPS (bonsai scale; guaranteed not to freeze)
        const SAFE_INST_LIMIT = 500;  // ≤500 instances total
        const SAFE_TERM_LIMIT = 180;  // ≤180 terminals used
        const PER_TERM_HARD_MAX = 16;   // ≤16 leaves per terminal
        const CHILDREN_HARD_MAX = 3;    // ≤3 children per joint
        const SEGMENTS_HARD_MAX = 800;  // ≤800 branch segments
        const ATTACH_MAX = 48; // hard cap on number of trunk attachment joints we’ll use

        let globalLeafCount = 0;

        // ---- Phase A: Instancing state
        let leafIMesh = null;            // InstancedMesh for leaf-like shapes
        let petalIMesh = null;           // (optional separate set when leafType === 'petal')
        let leafMatrices = [];           // collected instance transforms for leaves
        let petalMatrices = [];          // collected instance transforms for petals
        let leafInstanceCount = 0;       // HUD
        let petalInstanceCount = 0;      // HUD

        // ---- Phase B: terminal collection + allocation
        let terminals = [];    // { pos:Vector3, dir:Vector3, level:int, hNorm:number (0..1) }

        let spinPivotY = 0;    // world Y of vessel base

        let frameNo = 0;
        let fpsEMA = 0;          // exponential moving avg
        const FPS_ALPHA = 0.12;  // smoothing factor

        // Floating toolbar buttons
        const panelToggle = document.getElementById('panelToggle');
        const tbFrame = document.getElementById('tbFrame');
        const tbShot = document.getElementById('tbShot');
        const tbWire = document.getElementById('tbWire');
        const tbSpinL = document.getElementById('tbSpinL');
        const tbSlower = document.getElementById('tbSlower');
        const tbAuto = document.getElementById('tbAuto');
        const tbFaster = document.getElementById('tbFaster');
        const tbSpinR = document.getElementById('tbSpinR');
        const tbHelp = document.getElementById('tbHelp');

        // --- Scene ---
        const scene = new THREE.Scene();
        // If true, we auto refit after major layout changes (resize/panel toggle).
        const AUTO_REFIT_ON_LAYOUT = true;


        // Debug target gizmo (shows camera focus)
        const gizmo = new THREE.Group();
        const sphere = new THREE.Mesh(
            new THREE.SphereGeometry(0.05, 12, 12),
            new THREE.MeshBasicMaterial({ color: 0xffffff })
        );
        const axes = new THREE.AxesHelper(0.4);
        gizmo.add(axes, sphere);
        scene.add(gizmo);

        const camera = new THREE.PerspectiveCamera(38, 1, 0.1, 200);
        camera.position.set(6, 4.2, 11);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
        renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
        renderer.outputColorSpace = THREE.SRGBColorSpace;     // r160 uses outputColorSpace
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = parseFloat(exposureUI.value);
        stage.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.08;
        controls.minDistance = 2; controls.maxDistance = 60;
        controls.maxPolarAngle = Math.PI * 0.95; controls.target.set(0, 0, 0);
        controls.autoRotate = false; // disable internal camera spin

        const hemi = new THREE.HemisphereLight(0xf4efe8, 0x0b0f12, parseFloat(hemiLightUI.value));
        const dir = new THREE.DirectionalLight(0xffffff, parseFloat(keyLightUI.value)); dir.position.set(3, 5, 4);
        scene.add(hemi, dir);

        const root = new THREE.Group(); scene.add(root);
        let ike = new THREE.Group(); root.add(ike);
        let vesselGroup = null, treeGroup = null, sketchOverlay = null;
        let didInitialFrame = false;

        // --- Smooth autorotation & manual spin ---
        const clock = new THREE.Clock();
        let autoOn = true;              // default ON
        let holdSpin = 0;               // -1 = right, +1 = left while pressed
        const AUTO_BASE = 0.8;          // base radians/sec scale for speed slider

        const debugToggle = $('debugToggle');
        const hud = $('hud');

        // handy formatters
        const d = (n) => Number.isFinite(n) ? n.toFixed(3) : 'NaN';
        const deg = (r) => d(THREE.MathUtils.radToDeg(r));
        const v3 = (v) => `${d(v.x)}, ${d(v.y)}, ${d(v.z)}`;
        const eulerDeg = (e) => `${deg(e.x)}, ${deg(e.y)}, ${deg(e.z)}`;

        function renderHUD() {
            if (!debugToggle || !hud) return;
            const on = !!debugToggle.checked;
            hud.style.display = on ? 'block' : 'none';
            if (!on) return;

            // gather data
            const cam = camera;
            const tgt = controls.target;
            const ikeRot = ike.rotation;
            const ikePos = ike.position;
            const ikeScale = ike.scale;

            const ems = emissiveStrengthUI ? parseFloat(emissiveStrengthUI.value) : 0;
            const w = wireToggle ? (wireToggle.value === 'on') : false;

            const ri = renderer.info;

            // counts come from your generators:
            // lastBranchSegments, lastTerminalPieces, globalLeafCount
            // seed from currentSeed

            // vessel values
            const vType = vesselType ? vesselType.value : '';
            const vDia = vesselDia ? parseFloat(vesselDia.value) : 0;
            const vDep = vesselDepth ? parseFloat(vesselDepth.value) : 0;

            // tree settings
            const tSet = {
                type: treeType.value, levels: levels.value,
                bDepth: bDepth.value, bMin: bMin.value, bMax: bMax.value, bLen: bLen.value,
                curvature: curvature.value, uniformity: uniformity.value, upBias: upBias.value, spread: spread.value,
                density: density.value, leafSpread: leafSpread.value, leafType: leafType.value, plumage: plumage.value
            };

            const lines = [];
            lines.push(`<div class="hdr">runtime</div>`);
            lines.push(`<div><span class="k">frame</span> <span class="v">${frameNo}</span>  <span class="k">fps~</span> <span class="v">${fpsEMA.toFixed(1)}</span></div>`);
            lines.push(`<div><span class="k">auto</span> <span class="v">${autoOn ? 'on' : 'off'}</span>  <span class="k">speed</span> <span class="v">${autoSpeedUI ? autoSpeedUI.value : '—'}</span></div>`);
            lines.push(`<div class="hdr">camera</div>`);
            lines.push(`<div><span class="k">pos</span> <span class="v">${v3(cam.position)}</span></div>`);
            lines.push(`<div><span class="k">rot(deg)</span> <span class="v">${eulerDeg(cam.rotation)}</span></div>`);
            lines.push(`<div><span class="k">target</span> <span class="v">${v3(tgt)}</span></div>`);
            lines.push(`<div class="hdr">object (ike)</div>`);
            lines.push(`<div><span class="k">pos</span> <span class="v">${v3(ikePos)}</span></div>`);
            lines.push(`<div><span class="k">rot(deg)</span> <span class="v">${eulerDeg(ikeRot)}</span></div>`);
            lines.push(`<div><span class="k">scale</span> <span class="v">${v3(ikeScale)}</span></div>`);
            lines.push(`<div><span class="k">seed</span> <span class="v">${currentSeed}</span></div>`);
            lines.push(`<div class="hdr">vessel</div>`);
            lines.push(`<div><span class="k">type</span> <span class="v">${vType}</span></div>`);
            lines.push(`<div><span class="k">dia</span> <span class="v">${d(vDia)}</span>  <span class="k">depth</span> <span class="v">${d(vDep)}</span></div>`);
            lines.push(`<div class="hdr">tree</div>`);
            lines.push(`<div><span class="k">type</span> <span class="v">${tSet.type}</span>  <span class="k">levels</span> <span class="v">${tSet.levels}</span></div>`);
            lines.push(`<div><span class="k">branch</span> <span class="v">depth ${tSet.bDepth}, min ${tSet.bMin}, max ${tSet.bMax}, len ${tSet.bLen}</span></div>`);
            lines.push(`<div><span class="k">shape</span> <span class="v">curv ${tSet.curvature}, uni ${tSet.uniformity}, upBias ${tSet.upBias}, spread ${tSet.spread}</span></div>`);
            lines.push(`<div><span class="k">leaves</span> <span class="v">${tSet.leafType}, spread ${tSet.leafSpread}, density ${tSet.density}, plumage ${tSet.plumage}</span></div>`);
            lines.push(`<div class="hdr">render</div>`);
            lines.push(`<div><span class="k">mode</span> <span class="v">${renderMode.value}</span>  <span class="k">wire</span> <span class="v">${w ? 'on' : 'off'}</span>  <span class="k">emiss</span> <span class="v">${ems}</span></div>`);
            lines.push(`<div class="hdr">counts</div>`);
            lines.push(`<div><span class="k">segments</span> <span class="v">${lastBranchSegments}</span>  <span class="k">terminals</span> <span class="v">${lastTerminalPieces}</span>  <span class="k">globalLeaves</span> <span class="v">${globalLeafCount}</span></div>`);
            lines.push(`<div><span class="k">leaves(inst)</span> <span class="v">${leafInstanceCount}</span></div>`);
            if (petalInstanceCount > 0) {
                lines.push(`<div><span class="k">petals(inst)</span> <span class="v">${petalInstanceCount}</span></div>`);
            }
            lines.push(`<div><span class="k">targets</span> <span class="v">${terminals.length} terms → ${leafInstanceCount} leaves</span></div>`);
            lines.push(`<div class="hdr">gpu</div>`);
            lines.push(`<div><span class="k">calls</span> <span class="v">${ri.render.calls}</span>  <span class="k">tri</span> <span class="v">${ri.render.triangles}</span>  <span class="k">points</span> <span class="v">${ri.render.points}</span></div>`);


            hud.innerHTML = lines.join('');
        }

        function debounce(fn, ms = 120) {
            let t = 0;
            return (...args) => {
                clearTimeout(t);
                t = setTimeout(() => fn(...args), ms);
            };
        }

        function spinBy(radPerSec, dt) {
            if (!radPerSec || !dt) return;
            // rotate the whole arrangement around Y at spin pivot
            // keep rotation “in place” visually relative to pivot Y
            ike.rotation.y += radPerSec * dt;
        }

        function applySpins(dt) {
            const uiSpeed = (autoSpeedUI) ? parseFloat(autoSpeedUI.value) : 0.8;
            if (autoOn && uiSpeed !== 0) spinBy(uiSpeed * AUTO_BASE, dt);
            if (holdSpin !== 0) spinBy(holdSpin * 1.2, dt);
        }

        // convenience from UI
        function setAutoRotate(on) {
            autoOn = !!on;                            // our smooth rot flag
            if (autoRotate) autoRotate.value = autoOn ? 'on' : 'off';
            if (autoBtn) autoBtn.textContent = autoOn ? '⏸ Pause' : '▶ Play';
        }

        function onResizeCore() {
            const rect = stage.getBoundingClientRect();
            const w = Math.max(1, Math.round(rect.width));
            const h = Math.max(1, Math.round(rect.height));

            // Set renderer buffer *and* element CSS size
            renderer.setSize(w, h, true); // true updates canvas.style.{width,height}
            // Defensive: make sure it fills its parent absolutely
            const c = renderer.domElement;
            c.style.position = 'absolute';
            c.style.inset = '0';
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
        }


        function refitSoon() {
            requestAnimationFrame(() => {
                // Ensure renderer size & aspect are synced first
                onResizeCore();
                // One authoritative frame after layout is stable
                frameView();
            });
        }

        // Debounced resize that can refit after layout shifts (e.g., panel show/hide, orientation changes)
        const onResize = debounce(() => {
            onResizeCore();
            if (AUTO_REFIT_ON_LAYOUT) refitSoon();
        }, 120);

        // Initial and listeners
        onResize();                         // run once after boot
        window.addEventListener('resize', onResize);

        // Keep renderer exactly matched to #stage via ResizeObserver
        const ro = new ResizeObserver(() => {
            onResizeCore();
            if (AUTO_REFIT_ON_LAYOUT) refitSoon();
        });
        ro.observe(document.getElementById('stageWrap'));



        // RNG
        function mulberry32(a) { return function () { let t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; }; }
        const seeded = (s) => mulberry32(s >>> 0);
        const rr = (r, min, max) => min + r() * (max - min);

        // Materials (DoubleSide to avoid backface holes)
        const DS = THREE.DoubleSide;
        const mats = {
            branch: new THREE.MeshToonMaterial({ color: 0x3b2d44, side: DS }),
            leaf: new THREE.MeshToonMaterial({ color: 0x2d6e52, transparent: true, opacity: 0.95, side: DS }),
            petal: new THREE.MeshToonMaterial({ color: 0xf3e7da, transparent: true, opacity: 0.98, side: DS }),
            accent: new THREE.MeshToonMaterial({ color: 0xd6b36a, transparent: true, opacity: 0.95, side: DS }),
            glass: new THREE.MeshPhysicalMaterial({ color: 0xa5b2bd, metalness: 0, roughness: 0.2, transmission: 0.9, ior: 1.2, thickness: 0.8, transparent: true, opacity: 0.85, side: DS }),
            water: new THREE.MeshPhysicalMaterial({ color: 0x5b7a86, metalness: 0, roughness: 0.4, transmission: 0.9, ior: 1.33, thickness: 0.2, transparent: true, opacity: 0.6, side: DS }),
            stone: new THREE.MeshStandardMaterial({ color: 0x545a5f, roughness: 0.9, metalness: 0.0, side: DS })
        };

        // Species presets
        const PRESETS = {
            magnolia: { spread: 0.6, upBias: 0.2, lenFalloff: 0.72, leaves: 'petal', trunk: 'arch', colors: { branch: 0x3b2d44, leaf: 0xf3e7da } },
            maple: { spread: 0.9, upBias: 0.15, lenFalloff: 0.70, leaves: 'diamond', trunk: 'splay', colors: { branch: 0x3b2d44, leaf: 0xd44a2f } },
            pine: { spread: 0.5, upBias: 0.6, lenFalloff: 0.76, leaves: 'needle', trunk: 'upright', branchPattern: 'whorl', colors: { branch: 0x2a3a2c, leaf: 0x1d4228 } },
            olive: { spread: 0.65, upBias: 0.4, lenFalloff: 0.74, leaves: 'slab', trunk: 'compact', colors: { branch: 0x403e3a, leaf: 0x6e7b64 } },
            juniper: { spread: 0.55, upBias: 0.45, lenFalloff: 0.75, leaves: 'teardrop', trunk: 'windswept', colors: { branch: 0x2e3a3f, leaf: 0x547b7c } },
            ginkgo: { spread: 0.8, upBias: 0.25, lenFalloff: 0.71, leaves: 'half', trunk: 'tiered', branchPattern: 'tiers', colors: { branch: 0x3b2d44, leaf: 0xe8b736 } }
        };

        let currentSeed = (Math.random() * 0xFFFFFFFF) >>> 0;
        let lastTerminalPieces = 0, lastBranchSegments = 0;

        function setSeed(seed) { currentSeed = seed >>> 0; seedLabel.textContent = String(currentSeed); }

        // Background textures
        function applyBackground() {
            const color = bgColor.value;
            bgOverlay.style.backgroundImage = '';
            if (bgTex.value === 'solid') {
                bgOverlay.style.background = color;
            } else if (bgTex.value === 'grain') {
                bgOverlay.style.background = `${color}`;
                bgOverlay.style.backgroundImage = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><filter id="n"><feTurbulence baseFrequency="0.8" type="fractalNoise" numOctaves="2"/><feColorMatrix type="saturate" values="0"/></filter><rect width="100" height="100" filter="url(%23n)" opacity="0.15"/></svg>')`;
                bgOverlay.style.backgroundBlendMode = 'overlay';
            } else if (bgTex.value === 'gradient') {
                bgOverlay.style.background = `radial-gradient(1000px 800px at 70% 25%, ${color}, #0a0e12)`;
            } else if (bgTex.value === 'paper') {
                bgOverlay.style.background = color;
                bgOverlay.style.backgroundImage = `linear-gradient(rgba(255,255,255,.03) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,.02) 1px, transparent 1px)`;
                bgOverlay.style.backgroundSize = '6px 6px, 6px 6px';
            }
        }

        function makeVessel(type, dia = 1.2, depth = 1.6) {
            if (vesselGroup) { ike.remove(vesselGroup); vesselGroup.traverse(o => { if (o.geometry) o.geometry.dispose(); }); }
            const g = new THREE.Group(); g.position.y = -1.6; vesselGroup = g; ike.add(g);
            const tint = new THREE.Color(vesselColor.value);
            mats.glass.color.copy(tint); mats.stone.color.copy(tint);
            if (type === 'glass-cylinder') {
                const outer = new THREE.Mesh(new THREE.CylinderGeometry(dia * 0.9, dia * 0.9, depth, 36, 1, true), mats.glass);
                const inner = new THREE.Mesh(new THREE.CylinderGeometry(dia * 0.82, dia * 0.82, depth * 0.92, 36, 1, true), mats.glass);
                const water = new THREE.Mesh(new THREE.CylinderGeometry(dia * 0.8, dia * 0.8, Math.max(0.2, depth * 0.45), 36), mats.water); water.position.y = -depth * 0.25;
                g.add(outer, inner, water);
            } else if (type === 'shallow-bowl') {
                const bowl = new THREE.Mesh(new THREE.CylinderGeometry(dia * 1.3, dia * 1.5, Math.max(0.25, depth * 0.35), 24, 1, true), mats.glass);
                bowl.position.y = -Math.max(0.05, depth * 0.1); g.add(bowl);
                const pool = new THREE.Mesh(new THREE.CylinderGeometry(dia * 1.2, dia * 1.2, Math.max(0.1, depth * 0.12), 24), mats.water); pool.position.y = -Math.max(0.08, depth * 0.18); g.add(pool);
            } else if (type === 'faceted') {
                const prism = new THREE.Mesh(new THREE.DodecahedronGeometry(Math.max(0.6, dia * 0.7), 0), mats.glass); prism.position.y = 0.1; g.add(prism);
            } else if (type === 'stone-disc') {
                const disc = new THREE.Mesh(new THREE.CylinderGeometry(dia * 1.4, dia * 1.4, Math.max(0.2, depth * 0.16), 36), mats.stone); disc.position.y = -depth * 0.6; g.add(disc);
            }
            return g;
        }

        function updateSpinPivotFromVessel() {
            if (!vesselGroup) return;
            const box = new THREE.Box3().setFromObject(vesselGroup);
            spinPivotY = box.min.y; // used for any future pivot math if needed
        }

        function orbitTargetToVesselBase() {
            if (!vesselGroup) return;
            const box = new THREE.Box3().setFromObject(vesselGroup);
            const baseY = box.min.y;
            controls.target.set(0, baseY, 0);
        }

        // Render styles (tree only)
        function applyRenderStyle() {
            const mode = renderMode.value;
            const wire = wireToggle.value === 'on';
            const branchColor = new THREE.Color(branchColorUI ? branchColorUI.value : mats.branch.color);
            const leafColor = new THREE.Color(leafColorUI ? leafColorUI.value : mats.leaf.color);
            const petalColor = mats.petal.color.clone();
            const emissiveCol = new THREE.Color(emissiveColorUI ? emissiveColorUI.value : leafColor);

            const setMat = (mesh, kind) => {
                let mat;
                if (mode === 'metallic') {
                    mat = new THREE.MeshStandardMaterial({
                        color: kind === 'branch' ? branchColor : (kind === 'petal' ? petalColor : leafColor),
                        metalness: 0.85, roughness: 0.25, wireframe: wire, side: DS
                    });
                }
                else if (mode === 'holographic') {
                    const base = new THREE.MeshPhysicalMaterial({
                        color: kind === 'branch' ? branchColor : (kind === 'petal' ? petalColor : leafColor),
                        metalness: 0.2, roughness: 0.1, transmission: 0.4,
                        transparent: true, opacity: 0.9, wireframe: wire, side: DS
                    });
                    base.onBeforeCompile = (shader) => {
                        shader.fragmentShader = shader.fragmentShader.replace('#include <output_fragment>', `
                        float fres = pow(1.0 - dot(normalize(vViewPosition), normalize(normal)), 2.0);
                        vec3 holo = mix(gl_FragColor.rgb, vec3(0.6,0.8,1.0), fres*0.9);
                        gl_FragColor = vec4(holo, gl_FragColor.a);
                    `);
                    };
                    mat = base;
                }
                else if (mode === 'emissive') {
                    mat = new THREE.MeshStandardMaterial({
                        color: (kind === 'branch' ? branchColor : (kind === 'petal' ? petalColor : leafColor)),
                        emissive: (kind === 'branch' ? branchColor : (kind === 'petal' ? petalColor : emissiveCol)),
                        emissiveIntensity: parseFloat(emissiveStrengthUI.value),
                        metalness: 0.0, roughness: 0.6, wireframe: wire, side: DS
                    });
                }
                else { // toon default
                    mat = (kind === 'petal') ? mats.petal.clone()
                        : (kind === 'branch' ? mats.branch.clone() : mats.leaf.clone());
                    mat.wireframe = wire; mat.side = DS;
                }
                mesh.material = mat;
            };

            if (treeGroup) {
                treeGroup.traverse(o => { if (o.isMesh) { const kind = o.userData.kind || 'branch'; setMat(o, kind); } });
            }

            if (sketchOverlay) { ike.remove(sketchOverlay); sketchOverlay.traverse(o => { if (o.geometry) o.geometry.dispose(); }); sketchOverlay = null; }
            if (mode === 'sketchy') {
                sketchOverlay = new THREE.Group();
                treeGroup.traverse(o => {
                    if (o.isMesh && o.geometry) {
                        const e = new THREE.EdgesGeometry(o.geometry, 15);
                        const lines = new THREE.LineSegments(e, new THREE.LineBasicMaterial({ color: 0x0b0b0b, transparent: true, opacity: 0.6 }));
                        lines.position.copy(o.position); lines.rotation.copy(o.rotation); lines.scale.copy(o.scale); lines.quaternion.copy(o.quaternion);
                        lines.userData.kind = 'sketch';
                        o.add(lines); sketchOverlay.add(lines);
                    }
                });
            }
        }

        // ---- Improved single-geometry factories for instancing (cached)
        // Produces a single BufferGeometry that visually matches each leaf/petal "kind".
        const __leafGeoCache = new Map();

        function instancingGeometryFor(kindRaw) {
            const kind = String(kindRaw || '').toLowerCase();

            if (__leafGeoCache.has(kind)) return __leafGeoCache.get(kind);

            let g = null;

            switch (kind) {

                // Rounded petal (capsule-like). Prefer CapsuleGeometry if available; otherwise Lathe.
                case 'petal': {
                    if (THREE.CapsuleGeometry) {
                        g = new THREE.CapsuleGeometry(0.12, 0.42, 8, 12);
                    } else {
                        // Lathe a rounded petal profile (teardrop-ish but symmetric)
                        const pts = [];
                        // build half-profile (top rounded, bottom rounded)
                        const R = 0.12, H = 0.54, N = 12;
                        for (let i = 0; i <= N; i++) {
                            const t = i / N;                      // 0..1
                            const y = -H * 0.5 + H * t;           // -H/2..H/2
                            // bulge more in the upper half to read like a petal
                            const bulge = 0.6 + 0.4 * Math.sin(Math.PI * t);
                            const r = R * bulge;
                            pts.push(new THREE.Vector2(r, y));
                        }
                        g = new THREE.LatheGeometry(pts, 20);
                    }
                    break;
                }

                // Classic teardrop via Lathe (pointed tip)
                case 'teardrop':
                case 'tear':
                case 'tear-drop': {
                    const pts = [];
                    // Profile: round base -> taper to tip
                    const R = 0.14, H = 0.56, N = 18;
                    for (let i = 0; i <= N; i++) {
                        const t = i / N;             // 0..1 from base to tip
                        const y = -H * 0.4 + H * 0.9 * t; // slightly off-center
                        // radius: big at base, smoothly to ~0 at tip (t^0.6 keeps more area mid)
                        const r = R * Math.pow(1 - t, 0.6);
                        pts.push(new THREE.Vector2(r, y));
                    }
                    g = new THREE.LatheGeometry(pts, 24);
                    break;
                }

                // Crescent (partial torus)
                case 'crescent': {
                    g = new THREE.TorusGeometry(0.22, 0.06, 10, 28, Math.PI * 1.2);
                    break;
                }

                // Sphere berry/leaves
                case 'sphere':
                case 'ball':
                case 'berry': {
                    g = new THREE.SphereGeometry(0.18, 16, 12);
                    break;
                }

                // Cone needle/triangle-ish (upright cone)
                case 'cone': {
                    g = new THREE.ConeGeometry(0.18, 0.5, 14);
                    break;
                }

                // Flat triangle leaf (single mesh). Use a very thin Prism to avoid single-sided planes.
                case 'triangle': {
                    const shape = new THREE.Shape();
                    shape.moveTo(0, 0.28);
                    shape.lineTo(-0.24, -0.18);
                    shape.lineTo(0.24, -0.18);
                    shape.closePath();
                    const extrude = { depth: 0.02, bevelEnabled: false };
                    g = new THREE.ExtrudeGeometry(shape, extrude);
                    // orient so the "length" is along local Y; Extrude extrudes along +Z, so rotate:
                    g.rotateX(Math.PI / 2);
                    break;
                }

                // Rhombus (diamond). Thin extruded so it’s double-sided-ish.
                case 'diamond':
                case 'rhombus': {
                    const shape = new THREE.Shape();
                    shape.moveTo(0, 0.28);
                    shape.lineTo(-0.18, 0);
                    shape.lineTo(0, -0.28);
                    shape.lineTo(0.18, 0);
                    shape.closePath();
                    const extrude = { depth: 0.02, bevelEnabled: false };
                    g = new THREE.ExtrudeGeometry(shape, extrude);
                    g.rotateX(Math.PI / 2);
                    break;
                }

                // Half circle leaf (fan). Use CircleGeometry partial arc.
                case 'half':
                case 'half-circle':
                case 'half_circle':
                case 'semicircle': {
                    g = new THREE.CircleGeometry(0.24, 24, Math.PI, Math.PI); // thetaStart=PI, thetaLength=PI
                    // make it thin 3D so it always renders; turn disc into a thin cylinder-like shell:
                    g = g.toNonIndexed(); // ensure clean scale
                    // give it a tiny thickness by scaling Z afterwards via matrix on instance (we already do uniform scale).
                    // Instead, we extrude a tiny amount:
                    // fallback: keep as flat disc; ensure material is DoubleSide in your mats.leaf if needed.
                    break;
                }

                // Oval/ellipse leaf
                case 'oval':
                case 'ellipse': {
                    g = new THREE.CircleGeometry(0.18, 24);
                    g.scale(1.0, 1.0, 1.0);   // base
                    // make it elliptical by scaling Y after we orient it:
                    g.rotateX(Math.PI / 2);
                    g.scale(1.0, 0.6, 1.0);
                    break;
                }

                // Needle (thin cylinder)
                case 'needle': {
                    g = new THREE.CylinderGeometry(0.02, 0.02, 0.7, 8);
                    break;
                }

                // Slab (broad rectangular)
                case 'slab': {
                    g = new THREE.BoxGeometry(0.3, 0.06, 0.18);
                    break;
                }

                // Default: simple narrow box (works as a general leaf if kind unknown)
                default: {
                    g = new THREE.BoxGeometry(0.12, 0.8, 0.02);
                    break;
                }
            }

            __leafGeoCache.set(kind, g);
            return g;
        }


        function regenerate() {
            // Snapshot camera + object transforms (to restore exactly)
            const camPos = camera.position.clone();
            const camTarget = controls.target.clone();

            // Preserve ike transform so object rotation never resets
            const ikePos = ike.position.clone();
            const ikeRot = ike.rotation.clone();
            const ikeScale = ike.scale.clone();

            // Clear children instead of replacing `ike`
            if (treeGroup) {
                ike.remove(treeGroup);
                treeGroup.traverse(o => { if (o.geometry) o.geometry.dispose(); });
                treeGroup = null;
            }
            if (vesselGroup) {
                ike.remove(vesselGroup);
                vesselGroup.traverse(o => { if (o.geometry) o.geometry.dispose(); });
                vesselGroup = null;
            }

            // Rebuild vessel + tree as children of the *same* `ike`
            makeVessel(vesselType.value, parseFloat(vesselDia.value), parseFloat(vesselDepth.value));

            // NOTE: do NOT re-center the camera target here.
            // Only recompute spin pivot, leave camera/target untouched.
            updateSpinPivotFromVessel();

            treeGroup = new THREE.Group();
            ike.add(treeGroup);

            // ---- Phase A: reset instancing state
            leafMatrices = [];
            petalMatrices = [];
            leafInstanceCount = 0;
            petalInstanceCount = 0;
            // Phase B reset
            terminals = [];


            // remove previous instanced meshes if any
            if (leafIMesh && leafIMesh.parent) { leafIMesh.parent.remove(leafIMesh); }
            if (petalIMesh && petalIMesh.parent) { petalIMesh.parent.remove(petalIMesh); }
            leafIMesh = null;
            petalIMesh = null;

            // keep the existing per-generation leaf cap reset
            globalLeafCount = 0;

            const preset = PRESETS[treeType.value];
            mats.branch.color.set(preset.colors.branch);
            mats.leaf.color.set(preset.colors.leaf);

            const depth = parseInt(levels.value, 10);
            const sp = parseFloat(spread.value) || preset.spread;
            const up = parseFloat(upBias.value) || preset.upBias;
            const lenFall = preset.lenFalloff;
            const leavesKind = leafType.value || preset.leaves;
            const curv = parseFloat(curvature.value);
            const uni = parseFloat(uniformity.value);
            const childMin = parseInt(bMin.value, 10);
            const childMax = parseInt(bMax.value, 10);
            const depthBranches = parseInt(bDepth.value, 10);
            const branchLenMul = parseFloat(bLen.value);
            const densityMul = parseFloat(density.value);
            const leafSpreadMul = parseFloat(leafSpread.value);

            globalLeafCount = 0; // <-- reset once per generation HERE

            const r = seeded(currentSeed);

            // Trunk
            const trunkGroup = new THREE.Group(); treeGroup.add(trunkGroup);
            lastBranchSegments = 0;
            function addSegment(a, b, thickness) {
                const dir = new THREE.Vector3().subVectors(b, a); const len = dir.length(); dir.normalize();
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(thickness, thickness, len));
                mesh.userData.kind = 'branch';
                const quat = new THREE.Quaternion(); quat.setFromUnitVectors(new THREE.Vector3(0, 0, 1), dir);
                mesh.quaternion.copy(quat); mesh.position.copy(a.clone().addScaledVector(dir, len / 2));
                trunkGroup.add(mesh); lastBranchSegments++;
            }

            const pts = []; let p = new THREE.Vector3(rr(r, -0.05, 0.05), -0.9, rr(r, -0.05, 0.05));
            const upVec = new THREE.Vector3(0, 1, 0);
            let dir0 = new THREE.Vector3(rr(r, -0.1, 0.1), 1, rr(r, -0.1, 0.1)).normalize();
            let len = 2.6;
            const heightMul = Math.max(0.3, Math.min(1.6, parseFloat($('heightScale').value) || 1.0));
            const bendDir = (preset.trunk === 'windswept') ? new THREE.Vector3(1, 0, 0) : new THREE.Vector3(rr(r, -1, 1), 0, rr(r, -1, 1));
            bendDir.normalize().multiplyScalar(0.6 * curv);

            for (let i = 0; i < depth; i++) {
                let yawBias = bendDir.x * 0.35 + (1 - uni) * rr(r, -0.3, 0.3);
                let pitchBias = (preset.trunk === 'upright' ? 0.08 : 0.15) * curv + (1 - uni) * rr(r, -0.2, 0.2) + up * 0.05;
                if (preset.trunk === 'tiered' && i % 2 === 0) { yawBias *= 0.35; pitchBias *= 0.2; }
                if (preset.trunk === 'compact') { yawBias *= 0.5; pitchBias *= 0.5; }
                if (preset.trunk === 'splay') { yawBias += rr(r, -0.15, 0.15); }
                dir0 = dir0.clone().applyAxisAngle(upVec, yawBias).applyAxisAngle(new THREE.Vector3(1, 0, 0), pitchBias).normalize();
                const np = p.clone().addScaledVector(dir0, len * heightMul);
                np.add(new THREE.Vector3(rr(r, -0.10, 0.10), rr(r, -0.05, 0.05), rr(r, -0.10, 0.10)).multiplyScalar(curv * 0.35));
                pts.push([p.clone(), np.clone(), Math.max(0.035, 0.10 * Math.pow(lenFall, i))]);
                p = np; len *= lenFall * rr(r, 0.95, 1.05);
            }
            pts.forEach(([a, b, t]) => addSegment(a, b, t));

            // Direction preferences
            function preferredDir(baseDir) {
                const mode = plumage.value;
                if (mode === 'upward') return new THREE.Vector3(0, 1, 0);
                if (mode === 'radial') return baseDir.clone();
                if (mode === 'wind-left') return new THREE.Vector3(-1, 0.2, 0).normalize();
                if (mode === 'wind-right') return new THREE.Vector3(1, 0.2, 0).normalize();
                return null;
            }

            // Foliage
            const foliageGroup = new THREE.Group(); treeGroup.add(foliageGroup);
            lastTerminalPieces = 0;

            // Phase B: only record terminal metadata here.
            // levelIdx must be passed by the branch recursion.
            // If you don't have level info yet, temporarily pass 0; we'll wire real levels in Step 4.
            function addTerminal(p, dir, levelIdx = 0) {
                // Compute normalized height 0..1 along trunk/world (we’ll improve this if you already compute it)
                // If you already have a proper height (e.g., y range or trunk length), use that mapping instead.
                // Here we assume world Y min/max are roughly known; fall back to position.y heuristic.
                const y = p.y;
                // Simple normalization guard; if you have trunkMinY/trunkMaxY, use them.
                // For now, clamp to [0,1] using a rough band centered near 0:
                const hNorm = Math.max(0, Math.min(1, (y + 1.0) * 0.5)); // placeholder if you lack trunk bounds

                terminals.push({
                    pos: p.clone(),
                    dir: dir.clone().normalize(),
                    level: levelIdx | 0,
                    hNorm
                });
            }

            // ---- Phase B allocator + emitter
            function emitLeavesForTerminals() {
                // Read UI
                // Respect hard caps no matter what the UI says
                const uiMax = parseInt($('maxLeaves').value, 10) || 600;
                const MAX_LEAVES = Math.min(SAFE_INST_LIMIT, Math.max(50, uiMax));

                const lowerBias = Math.max(0, Math.min(1, parseFloat($('lowerBias').value) || 0));

                const uiMinPT = parseInt($('minPerTerminal').value, 10) || 0;
                const uiMaxPT = parseInt($('maxPerTerminal').value, 10) || 12;
                // Clamp per-terminal bounds to our hard envelope
                const minPT = Math.max(0, Math.min(uiMinPT, PER_TERM_HARD_MAX));
                const maxPT = Math.max(1, Math.min(uiMaxPT, PER_TERM_HARD_MAX));
                // Soft per-terminal density suggestion (does not affect branching anymore)
                const densityMul = Math.max(0.3, Math.min(3.0, parseFloat($('density').value) || 1));
                // We'll use it as a gentle multiplier when computing weights -> quotas per terminal


                // If no terminals, nothing to do
                if (!terminals.length) return;
                // If there are too many terminals, sample down to SAFE_TERM_LIMIT deterministically
                if (terminals.length > SAFE_TERM_LIMIT) {
                    const keep = SAFE_TERM_LIMIT;
                    const stride = terminals.length / keep;
                    const sampled = [];
                    for (let i = 0; i < terminals.length; i += stride) {
                        sampled.push(terminals[Math.floor(i)]);
                    }
                    terminals = sampled;
                }

                // 1) Group terminals by level (avoid name clash with global "levels" slider)
                const lvlMap = new Map(); // levelIdx -> array of terminals
                let minLevel = Infinity, maxLevel = -Infinity;
                for (const t of terminals) {
                    if (!lvlMap.has(t.level)) lvlMap.set(t.level, []);
                    lvlMap.get(t.level).push(t);
                    if (t.level < minLevel) minLevel = t.level;
                    if (t.level > maxLevel) maxLevel = t.level;
                }

                // Normalize level indices to 0..L-1 for smoother shares
                const levelOrder = Array.from(lvlMap.keys()).sort((a, b) => a - b);
                const L = levelOrder.length;
                const levelIndexMap = new Map();
                levelOrder.forEach((lvl, i) => levelIndexMap.set(lvl, i));


                // 2) Decide per-level share of the global budget
                // Base: uniform
                const baseShare = 1 / L;
                const levelShares = new Array(L).fill(baseShare);

                // Apply lower-canopy bias: more weight to lower indices (i=0 is low)
                // We compute a triangular distribution blended with uniform by lowerBias.
                if (lowerBias > 0) {
                    let sum = 0;
                    for (let i = 0; i < L; i++) {
                        const w = (L - i); // higher for lower levels
                        levelShares[i] = (1 - lowerBias) * baseShare + lowerBias * (w / (L * (L + 1) / 2));
                        sum += levelShares[i];
                    }
                    // renormalize
                    for (let i = 0; i < L; i++) levelShares[i] /= sum;
                }

                // 3) Allocate per-level quotas
                const levelQuotas = levelShares.map(s => Math.max(0, Math.round(s * MAX_LEAVES)));

                // 4) Within each level, distribute quota to terminals based on weights
                // Weight by height and mild evenness. Lower or mid heights can be preferred; here we favor mid slightly.
                const terminalTargets = new Map(); // terminal -> integer count
                let allocatedTotal = 0;

                for (let i = 0; i < L; i++) {
                    const lvlKey = levelOrder[i];
                    const arr = lvlMap.get(lvlKey);
                    const Q = levelQuotas[i];
                    if (!arr || arr.length === 0 || Q <= 0) continue;

                    // compute weights per terminal
                    const weights = [];
                    let wsum = 0;

                    for (const t of arr) {
                        const h = Math.max(0, Math.min(1, t.hNorm));
                        const mid = Math.sin(Math.PI * h);
                        let w = 0.25 + 0.75 * mid;
                        // NEW: let density gently increase the “desire” to allocate here
                        w *= densityMul;
                        weights.push(w);
                        wsum += w;
                    }

                    // Distribute Q across arr
                    // First pass: raw proportional
                    const provisional = new Array(arr.length).fill(0);
                    if (wsum <= 0) {
                        // even split
                        provisional.fill(Q / arr.length);
                    } else {
                        for (let k = 0; k < arr.length; k++) {
                            provisional[k] = (weights[k] / wsum) * Q;
                        }
                    }

                    // Apply per-terminal min/max with rounding, then adjust to hit Q
                    let intSum = 0;
                    for (let k = 0; k < arr.length; k++) {
                        provisional[k] = Math.max(minPT, Math.min(maxPT, Math.round(provisional[k])));
                        intSum += provisional[k];
                    }

                    // If we overshot due to mins/maxes, trim proportionally
                    // If we overshot due to mins/maxes, try to adjust toward Q safely
                    const delta = intSum - Q;
                    if (delta !== 0) {
                        // Compute how much adjustment is actually possible within [minPT, maxPT]
                        const reduceCapacity = provisional.reduce((s, v) => s + Math.max(0, v - minPT), 0); // how many we could remove
                        const addCapacity = provisional.reduce((s, v) => s + Math.max(0, maxPT - v), 0);  // how many we could add

                        // Target adjustment we will attempt (never more than capacity)
                        let need = Math.abs(delta);
                        if (delta > 0) need = Math.min(need, reduceCapacity);
                        else need = Math.min(need, addCapacity);

                        if (need > 0) {
                            // Order terminals: when trimming, nibble from largest; when adding, feed the smallest
                            const order = provisional
                                .map((v, idx) => ({ v, idx }))
                                .sort((a, b) => delta > 0 ? (b.v - a.v) : (a.v - b.v));

                            // Round-robin adjust up to `need` steps, but also hard-limit passes to avoid loops
                            let d = need;
                            let pos = 0;
                            let passes = 0;
                            const MAX_PASSES = arr.length * 4; // generous but finite

                            while (d > 0 && order.length > 0 && passes < MAX_PASSES) {
                                const idx = order[pos % order.length].idx;
                                const cur = provisional[idx];

                                if (delta > 0) { // need to reduce
                                    if (cur > minPT) { provisional[idx] = cur - 1; d--; }
                                } else {         // need to add
                                    if (cur < maxPT) { provisional[idx] = cur + 1; d--; }
                                }

                                pos++;
                                if (pos % order.length === 0) passes++;
                            }
                        }
                        // If we couldn’t fully reach Q due to bounds, that’s OK; we prefer stability over exact match.
                    }


                    // Record terminal targets
                    for (let k = 0; k < arr.length; k++) {
                        terminalTargets.set(arr[k], provisional[k]);
                        allocatedTotal += provisional[k];
                    }

                }

                // ---- FINAL GLOBAL CLAMP (never exceed SAFE_INST_LIMIT)
                // Only shrink when we exceed the limit; never "top up" when under.
                if (allocatedTotal > SAFE_INST_LIMIT) {
                    const scale = SAFE_INST_LIMIT / allocatedTotal;
                    const entries = Array.from(terminalTargets.entries());

                    // Proportional shrink + clamp to [0, maxPT]
                    for (let i = 0; i < entries.length; i++) {
                        const [term, count] = entries[i];
                        entries[i][1] = Math.max(0, Math.min(maxPT, Math.floor(count * scale)));
                    }

                    // Write back
                    terminalTargets.clear();
                    let sum = 0;
                    for (const [term, c] of entries) { terminalTargets.set(term, c); sum += c; }
                    allocatedTotal = Math.min(SAFE_INST_LIMIT, sum);
                }
                // If allocatedTotal <= SAFE_INST_LIMIT, do nothing — being under budget is fine.


                // Reuse Phase A per-leaf placement code here (no cap checks now)
                const spreadR = parseFloat(leafSpread.value);
                const uni = parseFloat(uniformity.value);
                const upBiasVal = parseFloat(upBias.value);
                const kind = leafType.value;

                const base = new THREE.Object3D();
                const tmp = new THREE.Object3D();

                // NOTE: do not reset leafMatrices here; regenerate() already reset them
                for (const t of terminals) {
                    const count = terminalTargets.get(t) | 0;
                    if (count <= 0) continue;

                    // terminal local frame aligned with t.dir (Z-forward)
                    base.position.copy(t.pos);
                    base.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), t.dir);
                    base.updateMatrix();

                    for (let i = 0; i < count; i++) {
                        const az = (i / count) * Math.PI * 2 + (1 - uni) * (Math.random() - 0.5) * 0.6;
                        const rad = spreadR * (0.15 + 0.85 * Math.random());
                        const lx = Math.cos(az) * rad;
                        const ly = (Math.random() - 0.3) * 0.2;
                        const lz = Math.sin(az) * rad;

                        tmp.position.set(lx, ly, lz);
                        const yaw = (Math.random() - 0.5) * (1 - uni) * 1.2;
                        const pitch = (Math.random() - 0.5) * (1 - uni) * 0.6 - upBiasVal * 0.15;
                        tmp.rotation.set(pitch, yaw, 0);
                        // Leaf size & variation
                        const sizeBase = Math.max(0.05, parseFloat($('leafSize').value) || 1.0); // base scale
                        const sizeVar = Math.max(0, Math.min(0.9, parseFloat($('leafVar').value) || 0.25)); // 0..0.9

                        // random factor in [-sizeVar, +sizeVar]
                        const jitter = (Math.random() * 2 - 1) * sizeVar;
                        // final per-leaf scale
                        const s = sizeBase * (1 + jitter);
                        tmp.scale.set(s, s, s);
                        tmp.updateMatrix();

                        const m = new THREE.Matrix4().multiplyMatrices(base.matrix, tmp.matrix);

                        if (kind === 'petal') {
                            petalMatrices.push(m);
                            petalInstanceCount++;
                        } else {
                            leafMatrices.push(m);
                            leafInstanceCount++;
                        }
                    }
                }
            }

            // Phase C: choose trunk joints for first-level branch attachments
            // pts: array of [a,b] vectors per trunk segment (you already have this in your code)
            // startNorm: minimum normalized height [0..1] to allow attachments
            // lowerBias: 0 = uniform, 1 = strongly favors lower joints
            // maxCount: safety cap
            function pickAttachmentIndices(pts, startNorm, lowerBias, maxCount) {
                const N = pts.length;
                if (N <= 2) return [];

                // Build candidates: use each segment’s END point "b" as the attachment height sample
                const cand = [];
                for (let i = 1; i < N; i++) {
                    // normalized height 0..1 by index along trunk (cheap and robust)
                    const h = i / (N - 1);
                    if (h < startNorm) continue; // below start height → skip
                    cand.push({ i, h });
                }
                if (cand.length === 0) return [];

                // Weighting: blend uniform with a simple "favor lower" curve (1 - h)
                // w = (1 - lowerBias) * 1 + lowerBias * (1 - h)
                for (const c of cand) {
                    c.w = (1 - lowerBias) * 1 + lowerBias * (1 - c.h);
                }

                // Sort by weight desc so the "best" joints come first
                cand.sort((a, b) => b.w - a.w);

                // Deterministic downsampling: take up to maxCount,
                // and if there are many, stride through to keep them spread out
                const take = Math.min(maxCount, cand.length);
                if (cand.length === take) return cand.map(c => c.i);

                const out = [];
                const stride = (cand.length - 1) / Math.max(1, take - 1);
                for (let k = 0; k < take; k++) {
                    out.push(cand[Math.round(k * stride)].i);
                }
                // Ensure unique and sorted increasing (important for levelIdx coherence)
                return Array.from(new Set(out)).sort((a, b) => a - b);
            }


            // Recursive branching
            function grow(origin, dirBase, levelIdx, depthLeft) {
                if (lastBranchSegments >= SEGMENTS_HARD_MAX) {
                    addTerminal(origin, dirBase, levelIdx);
                    return;
                }
                const pref = preferredDir(dirBase);
                const yaw = rr(r, -sp, sp) * Math.PI * 0.6 * (1 - uni);
                const pitch = rr(r, -0.2, 0.2) * Math.PI * 0.3 * (1 - uni) - rr(r, 0, up) * 0.2;
                let dir = dirBase.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw).applyAxisAngle(new THREE.Vector3(1, 0, 0), pitch);
                if (pref) { dir = dir.lerp(pref, uni).normalize(); } else dir.normalize();
                // --- Phase D: branch length with mean + variation + per-depth falloff ---
                const meanMul = Math.max(0.1, (parseFloat(bLen.value) || branchLenMul || 1.0)); // keep your slider as mean
                const varPct = Math.max(0, Math.min(0.9, parseFloat($('bLenVar').value) || 0.25));
                const fallMul = Math.max(0.60, Math.min(0.98, parseFloat($('bFall').value) || 0.85));

                // per-branch random jitter in [-varPct, +varPct]
                const jitter = (Math.random() * 2 - 1) * varPct;

                // a tiny micro-jitter so things aren't too uniform
                const micro = rr ? rr(r, 0.97, 1.03) : 1.0;

                // Base unit you used before was (2.6 * 0.45). We’ll keep that.
                // IMPORTANT: We replace Math.pow(lenFall, levelIdx) with Math.pow(fallMul, levelIdx)
                // so the user slider controls per-depth taper for *branches*.
                const baseUnit = (2.6 * 0.45);
                const L = baseUnit * meanMul * Math.pow(fallMul, levelIdx) * (1 + jitter) * micro;
                const end = origin.clone().addScaledVector(dir, L);
                const t = Math.max(0.02, 0.07 * Math.pow(lenFall, levelIdx + 1));
                const seg = new THREE.Mesh(new THREE.BoxGeometry(t, t, L)); seg.userData.kind = 'branch';
                const q = new THREE.Quaternion(); q.setFromUnitVectors(new THREE.Vector3(0, 0, 1), dir);
                seg.quaternion.copy(q); seg.position.copy(origin.clone().addScaledVector(dir, L / 2));
                trunkGroup.add(seg); lastBranchSegments++;

                if (depthLeft <= 1) { addTerminal(end, dir, levelIdx); return; }

                // spawn children from this endpoint
                let n = Math.floor(rr(r, childMin, childMax + 1));

                // pattern baselines (without density multipliers)
                if (PRESETS[treeType.value].branchPattern === 'whorl') n = Math.max(3, 4);
                if (PRESETS[treeType.value].branchPattern === 'tiers') n = Math.max(2, 3);

                // depth falloff (gentle): fewer children as we go up the levels
                n = Math.max(1, Math.round(n * Math.pow(0.78, levelIdx)));

                // hard cap to stop explosion
                n = Math.min(n, CHILDREN_HARD_MAX);

                for (let k = 0; k < n; k++) {
                    let dirChild = dir.clone();
                    if (PRESETS[treeType.value].branchPattern === 'whorl') {
                        const yawW = (k / n) * Math.PI * 2;
                        dirChild.applyAxisAngle(new THREE.Vector3(0, 1, 0), yawW);
                    }
                    grow(end, dirChild, levelIdx + 1, depthLeft - 1);
                }

            }

            // Phase C: choose attachment joints along the trunk using bias + start height
            const startNorm = Math.max(0, Math.min(1, parseFloat($('branchStart').value) || 0));
            const attachBias = Math.max(0, Math.min(1, parseFloat($('branchBias').value) || 0));
            const attachIndices = pickAttachmentIndices(pts, startNorm, attachBias, ATTACH_MAX);

            // Spawn first-level branches from chosen joints
            for (let ai = 0; ai < attachIndices.length; ai++) {
                const i = attachIndices[ai];
                const [a, b] = pts[i];
                const dir = new THREE.Vector3().subVectors(b, a).normalize();

                // root fan of first-level branches from each joint (still capped; no density multiplier)
                let n0 = Math.max(1, Math.floor(rr(r, childMin, childMax + 1)));
                if (PRESETS[treeType.value].branchPattern === 'whorl') n0 = Math.max(3, 4);
                n0 = Math.min(n0, CHILDREN_HARD_MAX);

                for (let m = 0; m < n0; m++) {
                    let d0 = dir.clone();
                    if (PRESETS[treeType.value].branchPattern === 'whorl') {
                        const yaw0 = (m / n0) * Math.PI * 2;
                        d0.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw0);
                    }
                    // Use i as levelIdx anchor (consistent with your existing scheme)
                    grow(b, d0, i, depthBranches);
                }
            }

            // Phase B: allocate and create leaf instance matrices from recorded terminals
            emitLeavesForTerminals();
            // ---- Phase A: build instanced meshes for leaves/petals
            const leafKindNow = leafType.value;

            // LEAVES (non-petal)
            if (leafMatrices.length > 0 && leafKindNow !== 'petal') {
                const gLeaf = instancingGeometryFor(leafKindNow);
                leafIMesh = new THREE.InstancedMesh(gLeaf, mats.leaf, leafMatrices.length);
                leafIMesh.userData.kind = 'leaf';
                for (let i = 0; i < leafMatrices.length; i++) {
                    leafIMesh.setMatrixAt(i, leafMatrices[i]);
                }
                leafIMesh.instanceMatrix.needsUpdate = true;
                treeGroup.add(leafIMesh);
            }

            // PETALS (when leaf type is petal, keep a separate set)
            if (petalMatrices.length > 0 && leafKindNow === 'petal') {
                const gPetal = instancingGeometryFor('petal');
                petalIMesh = new THREE.InstancedMesh(gPetal, mats.leaf, petalMatrices.length);
                petalIMesh.userData.kind = 'petal';
                for (let i = 0; i < petalMatrices.length; i++) {
                    petalIMesh.setMatrixAt(i, petalMatrices[i]);
                }
                petalIMesh.instanceMatrix.needsUpdate = true;
                treeGroup.add(petalIMesh);
            }

            globalLeafCount = leafInstanceCount + petalInstanceCount;

            applyRenderStyle();

            // --- keep camera EXACTLY the same (prevent tiny drift) ---
            const dampingWas = controls.enableDamping;
            const autoWas = (typeof controls.autoRotate === 'boolean') ? controls.autoRotate : false;
            const enabledWas = controls.enabled;
            const holdWas = holdSpin;

            holdSpin = 0;
            controls.enableDamping = false;
            controls.enabled = false;
            if (typeof controls.autoRotate === 'boolean') controls.autoRotate = false;

            // Restore camera transforms exactly
            camera.position.copy(camPos);
            controls.target.copy(camTarget);
            camera.updateProjectionMatrix();

            // Restore ike transform exactly (object stays where user left it)
            ike.position.copy(ikePos);
            ike.rotation.copy(ikeRot);
            ike.scale.copy(ikeScale);

            // Update zoom bounds after rebuild (keeps mobile zoom sane)
            try { updateZoomBoundsFromBox(getSceneBounds()); } catch (e) { }

            // Restore flags
            controls.enableDamping = dampingWas;
            controls.enabled = enabledWas;
            if (typeof controls.autoRotate === 'boolean') controls.autoRotate = autoWas;
            holdSpin = holdWas;
        }

        function applyVesselOnly() {
            makeVessel(vesselType.value, parseFloat(vesselDia.value), parseFloat(vesselDepth.value));
            updateSpinPivotFromVessel();
        }

        function savePNG() {
            const a = document.createElement('a'); a.download = `bonsai_${Date.now()}.png`; a.href = renderer.domElement.toDataURL('image/png'); a.click();
        }

        function tick() {
            const dt = clock.getDelta();
            const fps = dt > 0 ? (1 / dt) : 0;
            fpsEMA = (fpsEMA === 0 ? fps : (FPS_ALPHA * fps + (1 - FPS_ALPHA) * fpsEMA));
            frameNo++;
            applySpins(dt);          // << smooth spin is applied here
            controls.update();
            renderer.render(scene, camera);
            renderHUD();
            if (debugToggle && debugToggle.checked) {
                gizmo.visible = true;
                gizmo.position.copy(controls.target);
            } else {
                gizmo.visible = false;
            }


            requestAnimationFrame(tick);
        }

        // Bindings
        const bindLive = (el, fn) => { el.addEventListener('input', fn); el.addEventListener('change', fn); };
        const debRegenerate = debounce(regenerate, 120);

        [treeType, levels, curvature, uniformity, spread, upBias, bDepth, bMin, bMax, bLen, density, leafSpread, leafType, plumage,
            $('maxLeaves'), $('lowerBias'), $('minPerTerminal'), $('maxPerTerminal'),
            $('branchStart'), $('branchBias'),
            $('heightScale'), $('leafSize'), $('leafVar'),
            $('bLenVar'), $('bFall')
        ].forEach(el => bindLive(el, debRegenerate));

        [wireToggle, renderMode].forEach(el => bindLive(el, applyRenderStyle));
        [vesselType, vesselDia, vesselDepth, vesselColor].forEach(el => bindLive(el, applyVesselOnly));
        [bgColor, bgTex].forEach(el => bindLive(el, applyBackground));
        keyLightUI.addEventListener('input', () => { dir.intensity = parseFloat(keyLightUI.value); });
        hemiLightUI.addEventListener('input', () => { hemi.intensity = parseFloat(hemiLightUI.value); });
        exposureUI.addEventListener('input', () => { renderer.toneMappingExposure = parseFloat(exposureUI.value); });
        emissiveStrengthUI.addEventListener('input', applyRenderStyle);
        $('maxLeaves').addEventListener('input', e => $('maxLeaves_val').textContent = e.target.value);
        $('lowerBias').addEventListener('input', e => $('lowerBias_val').textContent = e.target.value);
        $('branchStart').addEventListener('input', e => $('branchStart_val').textContent = e.target.value);
        $('branchBias').addEventListener('input', e => $('branchBias_val').textContent = e.target.value);
        $('heightScale').addEventListener('input', e => $('heightScale_val').textContent = e.target.value);
        $('leafSize').addEventListener('input', e => $('leafSize_val').textContent = e.target.value);
        $('leafVar').addEventListener('input', e => $('leafVar_val').textContent = e.target.value);
        $('bLenVar').addEventListener('input', e => $('bLenVar_val').textContent = e.target.value);
        $('bFall').addEventListener('input', e => $('bFall_val').textContent = e.target.value);

        // Left/Right: smooth while held; also pause auto when you touch them
        function onHold(dir, isDown) {
            setAutoRotate(false);
            holdSpin = isDown ? dir : 0;
        }

        // Play/Pause + speed
        autoBtn.addEventListener('click', () => setAutoRotate(!autoOn));
        if (autoSpeedUI) autoSpeedUI.addEventListener('input', () => {/* no-op: read live in tick() */ });
        if (autoRotate) autoRotate.addEventListener('change', () => setAutoRotate(autoRotate.value === 'on'));

        if (debugToggle) {
            debugToggle.addEventListener('change', () => {
                // no-op; renderHUD() pulls the state each frame
            });
        }
        // handy hotkey: backtick toggles HUD
        window.addEventListener('keydown', (e) => {
            if (e.key === '`') {
                if (debugToggle) debugToggle.checked = !debugToggle.checked;
            }
        });

        function frameView() {
            // Measure bonsai bounds once
            const box = getSceneBounds();
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());

            // Stable pivot: vessel base if present, otherwise the bonsai center
            const pivot = getOrbitPivot();         // uses vessel minY when available
            controls.target.copy(pivot);

            // Current canvas aspect
            const { width, height } = renderer.domElement;
            const aspect = Math.max(1, width) / Math.max(1, height);

            // Choose a gentle oblique depending on aspect (taller phones need more Y)
            const viewDir = (aspect < 1)
                ? new THREE.Vector3(0.9, 0.95, 1).normalize()
                : new THREE.Vector3(1.0, 0.6, 1.0).normalize();

            // Fit distance by vertical FoV with a small margin
            const radius = Math.max(size.x, size.y, size.z) * 0.5 || 1.0;
            const dist = fitDistanceForSphere(radius, camera.fov, aspect, 1.18);

            camera.position.copy(pivot).addScaledVector(viewDir, dist);
            camera.near = Math.max(0.01, dist * 0.02);
            camera.far = Math.max(camera.near + 1, dist * 10);
            camera.lookAt(pivot);
            camera.updateProjectionMatrix();

            // Wider (and saner) zoom range on mobile
            const phone = window.innerWidth <= 900;
            controls.minDistance = Math.max(1.0, radius * (phone ? 0.8 : 0.7));
            controls.maxDistance = Math.max(controls.minDistance + 1, radius * (phone ? 7.5 : 5.5));
            controls.update();
        }



        // === Framing helpers (stable pivot + sphere) ===
        function getBonsaiSphere() {
            // Measure the bonsai content only
            const box = new THREE.Box3().setFromObject(ike);
            if (!isFinite(box.min.x) || !isFinite(box.max.x)) {
                return { center: new THREE.Vector3(0, 0, 0), radius: 1 };
            }
            const sphere = new THREE.Sphere();
            box.getBoundingSphere(sphere);
            return { center: sphere.center, radius: Math.max(0.001, sphere.radius) };
        }

        // Choose a single, never-drifting orbit pivot.
        // We’ll aim at vessel base if available, otherwise the bonsai sphere center.
        function getOrbitPivot() {
            if (vesselGroup) {
                const vb = new THREE.Box3().setFromObject(vesselGroup);
                const base = new THREE.Vector3(0, vb.min.y, 0);
                // Transform from ike-local to world:
                return base.applyMatrix4(ike.matrixWorld);
            }
            const { center } = getBonsaiSphere();
            return center;
        }

        // Distance to fit a sphere in view with a small margin.
        function fitDistanceForSphere(radius, fovDeg, aspect, margin = 1.15) {
            // fit by vertical FoV; vertical is the tight axis on tall phones
            const fov = THREE.MathUtils.degToRad(fovDeg);
            const fit = radius / Math.sin(fov * 0.5);
            return fit * margin;
        }

        // --- Mobile-friendly, bounds-driven framing/zoom ---

        function getSceneBounds() {
            // Measure the bonsai content only (avoid HUD/overlays)
            const box = new THREE.Box3().setFromObject(ike);
            if (!isFinite(box.min.x) || !isFinite(box.max.x)) {
                // Fallback small box if scene is empty/transitioning
                return new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1));
            }
            return box;
        }

        function updateZoomBoundsFromBox(box) {
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            const radius = Math.max(size.x, size.y, size.z) * 0.5 || 1.0;

            // Base distances from radius
            let minD = Math.max(1.2, radius * 0.8);
            let maxD = Math.max(minD + 1.0, radius * 5.0);

            // Phones: give more headroom
            if (window.innerWidth <= 900) {
                minD = Math.max(1.2, radius * 0.9);
                maxD = Math.max(minD + 1.0, radius * 6.0);
            }
            controls.minDistance = minD;
            controls.maxDistance = maxD;

            // Keep orbit target on the true center
            controls.target.copy(center);
            controls.update();
        }

        // Wrap frameView to always respect true bounds and sync zoom limits
        const __orig_frameView = frameView;
        frameView = function () {
            const box = getSceneBounds();
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());

            const maxDim = Math.max(size.x, size.y, size.z) || 1.0;
            const dist = maxDim / (2 * Math.tan(THREE.MathUtils.degToRad(camera.fov / 2))) + 2;

            // Slightly oblique vantage; works well on tall canvases too
            const viewDir = new THREE.Vector3(1, 0.6, 1).normalize();
            camera.position.copy(center).addScaledVector(viewDir, dist);
            camera.near = Math.max(0.01, dist * 0.02);
            camera.far = Math.max(camera.near + 1, dist * 10);
            camera.updateProjectionMatrix();

            updateZoomBoundsFromBox(box);
            camera.lookAt(center);
            controls.update();
        };


        if (shotBtn) shotBtn.addEventListener('click', savePNG);
        if (newSeedBtn) newSeedBtn.addEventListener('click', () => { setSeed((Math.random() * 0xFFFFFFFF) >>> 0); regenerate(); });

        // Keyboard shortcuts
        window.addEventListener('keydown', (e) => {
            // ignore when typing in inputs
            const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
            const isTyping = (tag === 'input' || tag === 'select' || tag === 'textarea' || e.target.isContentEditable);
            if (isTyping) return;

            if (e.code === 'Space') {
                e.preventDefault();
                // CURRENT: reseed
                // setSeed((Math.random() * 0xFFFFFFFF) >>> 0); regenerate();

                // SWITCH to play/pause instead:
                setAutoRotate(!autoOn);
                refreshTbAutoIcon();
            }

            if (e.key === 'f' || e.key === 'F') {
                e.preventDefault();
                tbFrame?.click();
            }

            else if (e.key === 'w' || e.key === 'W') {
                e.preventDefault();
                tbWire?.click();
            }
            else if (e.key === 'x' || e.key === 'X') {
                e.preventDefault();
                tbShot?.click();
            }
            else if (e.key === 'h' || e.key === 'H') {
                e.preventDefault();
                tbHelp && tbHelp.click();
            }
            else if (e.key === 'p' || e.key === 'P') {
                e.preventDefault();
                const now = !appRoot.classList.contains('panel-hidden');
                setPanelHidden(now);
            }
            else if (e.key === '[') {
                e.preventDefault();
                onHold(+1, true); // rotate left while held
            }
            else if (e.key === ']') {
                e.preventDefault();
                onHold(-1, true); // rotate right while held
            }
        });

        // stop rotate on keyup
        window.addEventListener('keyup', (e) => {
            if (e.key === '[') onHold(+1, false);
            if (e.key === ']') onHold(-1, false);
        });

        // === Theme switching ===
        (() => {
            const app = document.getElementById('app');
            const themeSelect = document.getElementById('themeSelect');
            const modeCtrl = document.getElementById('modeControl');
            const segBtns = [...modeCtrl.querySelectorAll('.seg')];

            // --- helpers ---
            const setPressed = (val) => {
                segBtns.forEach(b => {
                    const on = b.dataset.mode === val;
                    b.setAttribute('aria-pressed', on ? 'true' : 'false');
                    b.classList.toggle('is-active', on);
                });
            };

            const setAccentAndMode = (accent, mode) => {
                if (accent) app.setAttribute('data-accent', accent);
                if (mode) app.setAttribute('data-mode', mode);

                // Compute --text-on-accent dynamically for readability on buttons
                requestAnimationFrame(() => {
                    const cs = getComputedStyle(app);
                    // Pick a mid-strong swatch to judge contrast
                    const bg = cs.getPropertyValue('--accent-600').trim() || '#888';

                    const rgb = bg.startsWith('#') ? hexToRgb(bg) : cssColorToRgb(bg);
                    const L = relLuminance(rgb.r, rgb.g, rgb.b);
                    // If accent is bright, use near-black text; if dark, use white.
                    const text = (L > 0.6) ? '#0b0f12' : '#ffffff';
                    app.style.setProperty('--text-on-accent', text);
                });

                // Persist
                localStorage.setItem('bonsai.accent', app.getAttribute('data-accent'));
                localStorage.setItem('bonsai.mode', app.getAttribute('data-mode'));
            };

            // luminance utilities
            function relLuminance(r, g, b) {
                const sRGB = [r, g, b].map(v => v / 255).map(v => v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4));
                return 0.2126 * sRGB[0] + 0.7152 * sRGB[1] + 0.0722 * sRGB[2];
            }
            function hexToRgb(h) {
                const m = h.replace('#', '');
                const v = (m.length === 3) ? m.split('').map(x => x + x).join('') : m;
                return { r: parseInt(v.slice(0, 2), 16), g: parseInt(v.slice(2, 4), 16), b: parseInt(v.slice(4, 6), 16) };
            }
            function cssColorToRgb(c) {
                // Handles rgb()/hsl() via a canvas trick
                const ctx = document.createElement('canvas').getContext('2d');
                ctx.fillStyle = c;
                const m = ctx.fillStyle; // normalized to rgb(a)
                const nums = m.match(/\d+(\.\d+)?/g).map(Number);
                return { r: nums[0], g: nums[1], b: nums[2] };
            }

            // --- events ---
            segBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const mode = btn.dataset.mode;
                    setPressed(mode);
                    setAccentAndMode(null, mode);
                });
            });

            themeSelect.addEventListener('change', () => {
                const accent = themeSelect.value;
                setAccentAndMode(accent, null);
            });

            // --- initial sync (from storage or existing attrs) ---
            const storedAccent = localStorage.getItem('bonsai.accent') || app.getAttribute('data-accent') || 'cyan';
            const storedMode = localStorage.getItem('bonsai.mode') || app.getAttribute('data-mode') || 'light';

            // reflect in UI
            themeSelect.value = storedAccent;
            setPressed(storedMode);
            setAccentAndMode(storedAccent, storedMode);
        })();

        // Toolbar actions – forward to existing controls
        if (tbFrame) tbFrame.addEventListener('click', frameView);
        if (tbShot) tbShot.addEventListener('click', savePNG);
        if (tbWire) tbWire.addEventListener('click', () => {
            // toggle wire select & apply
            if (!wireToggle) return;
            wireToggle.value = (wireToggle.value === 'on') ? 'off' : 'on';
            applyRenderStyle();
        });

        // Rotate hold via same handlers you have for the side-panel buttons
        if (tbSpinL) {
            tbSpinL.addEventListener('mousedown', () => onHold(+1, true));
            tbSpinL.addEventListener('mouseup', () => onHold(+1, false));
            tbSpinL.addEventListener('touchstart', (e) => { e.preventDefault(); onHold(+1, true); }, { passive: false });
            tbSpinL.addEventListener('touchend', () => onHold(+1, false), { passive: true });
        }
        if (tbSpinR) {
            tbSpinR.addEventListener('mousedown', () => onHold(-1, true));
            tbSpinR.addEventListener('mouseup', () => onHold(-1, false));
            tbSpinR.addEventListener('touchstart', (e) => { e.preventDefault(); onHold(-1, true); }, { passive: false });
            tbSpinR.addEventListener('touchend', () => onHold(-1, false), { passive: true });
        }

        const canvasToolbar = document.getElementById('canvasToolbar');

        function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

        function setAutoSpeed(val) {
            if (!autoSpeedUI) return;
            const n = clamp(val, parseFloat(autoSpeedUI.min), parseFloat(autoSpeedUI.max));
            autoSpeedUI.value = String(n);
            // no need to call regenerate; tick() reads the live value
        }

        function refreshTbAutoIcon() {
            if (!tbAuto) return;
            tbAuto.textContent = autoOn ? '⏸' : '▶'; // pause/play glyph
            tbAuto.title = autoOn ? 'Pause (Space)' : 'Play (Space)';
        }

        if (tbAuto) {
            tbAuto.addEventListener('click', () => {
                setAutoRotate(!autoOn);
                refreshTbAutoIcon();
            });
            // also keep icon synced if someone uses the side panel control
            if (autoRotate) {
                autoRotate.addEventListener('change', refreshTbAutoIcon);
            }
            // initial glyph
            refreshTbAutoIcon();
        }

        if (tbSlower) {
            tbSlower.addEventListener('click', () => {
                const cur = parseFloat(autoSpeedUI.value || '0');
                setAutoSpeed(cur - 0.2);
                setAutoRotate(true);
                refreshTbAutoIcon();
            });
        }
        if (tbFaster) {
            tbFaster.addEventListener('click', () => {
                const cur = parseFloat(autoSpeedUI.value || '0');
                setAutoSpeed(cur + 0.2);
                setAutoRotate(true);
                refreshTbAutoIcon();
            });
        }


        const tipsBar = document.getElementById('tipsBar');
        if (tbHelp && tipsBar) {
            tbHelp.addEventListener('click', () => {
                const on = tipsBar.style.display !== 'none';
                tipsBar.style.display = on ? 'none' : 'flex';
            });
        }

        // Refit when the panel is toggled (class changes)
        const appRoot = document.getElementById('app');
        const obs = new MutationObserver(() => refitSoon());
        obs.observe(appRoot, { attributes: true, attributeFilter: ['class'] });

        function setPanelHidden(on) {
            appRoot.classList.toggle('panel-hidden', !!on);
            if (panelToggle) {
                panelToggle.setAttribute('aria-pressed', on ? 'true' : 'false');
            }
            // persist preference
            localStorage.setItem('bonsai.panelHidden', on ? '1' : '0');
            refitSoon();
        }

        // initial: prefer stored, else hide automatically on small screens
        (function initPanelHidden() {
            const stored = localStorage.getItem('bonsai.panelHidden');
            if (stored === '1' || (stored === null && window.innerWidth <= 900)) {
                setPanelHidden(true);
            }
        })();

        // Refit when the breakpoint crosses (layout rows/cols change)
        const mq = window.matchMedia('(max-width: 900px)');
        mq.addEventListener?.('change', () => refitSoon());

        if (panelToggle) {
            panelToggle.addEventListener('click', () => {
                const now = !appRoot.classList.contains('panel-hidden');
                setPanelHidden(now);
            });
        }

        function initial() {
            applyBackground();
            setSeed((Math.random() * 0xFFFFFFFF) >>> 0);
            regenerate();
            if (autoSpeedUI) { controls.autoRotateSpeed = parseFloat(autoSpeedUI.value); }
            setAutoRotate(true);
            tick();
            // Defer framing so the first paint happens before the bbox scan
            renderHUD();
            // Let the first frame render, then refit robustly (twice)
            refitSoon();

        }

        initial();

    </script>
</body>

</html>
