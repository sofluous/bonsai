<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Geometric Bonsai ‚Äî Ikebana Style</title>
    <style>
        /* =========================================================
   GEOMETRIC BONSAI ‚Äî Unified Design System (Techno Minimal)
   ========================================================= */

        /* =============== PRIMITIVES =============== */
        :root {
            /* Base surfaces */
            --c-bg-0: #0e1115;
            /* canvas */
            --c-bg-1: #0f141a;
            /* surface/panel */
            --c-bg-2: #141a22;
            /* controls */

            /* Text ramps */
            --c-text-strong: #e8eef7;
            --c-text-heading: #cbd3db;
            --c-text-subtle: #b9c6d3;
            --c-text-dim: #aeb9c5;

            /* Lines */
            --c-line: rgba(255, 255, 255, .08);
            --c-line-strong: rgba(255, 255, 255, .12);

            /* Accent generation (HSL-based; themes override these three) */
            --accent-h: 170;
            /* hue */
            --accent-s: 100%;
            /* saturation */
            --accent-l: 64%;
            /* base lightness */

            /* Derived accent palette (single hue, varied tones) */
            --accent-900: hsl(var(--accent-h) 90% 25%);
            --accent-700: hsl(var(--accent-h) 85% 40%);
            --accent-600: hsl(var(--accent-h) 85% 50%);
            --accent-500: hsl(var(--accent-h) 85% var(--accent-l));
            --accent-400: hsl(var(--accent-h) 88% 58%);
            /* main */
            --accent-300: hsl(var(--accent-h) 90% 78%);
            --accent-200: hsl(var(--accent-h) 90% 88%);
            --accent-100: hsl(var(--accent-h) 90% 94%);
            --accent-aura-outer: color-mix(in oklab, var(--accent-500) 22%, transparent);
            --accent-aura-inner: color-mix(in oklab, var(--accent-500) 10%, transparent);

            /* Layout & radii */
            --panel-w: 380px;
            --r-1: 6px;
            --r-2: 8px;
            --r-3: 10px;

            /* Spacing */
            --s-1: .35rem;
            --s-2: .6rem;
            --s-3: .7rem;
            --s-4: .75rem;
            --s-5: 1rem;

            /* Shadows/borders/glow */
            --bd-weak: 1px solid var(--c-line);
            --bd-strong: 1px solid var(--c-line-strong);
            --inset-col: var(--c-line);
            --shadow-inset: inset -1px 0 0 var(--inset-col), 1px 0 0 rgba(0, 0, 0, .25);
            --glow-outer: 0 0 12px var(--accent-aura-outer);
            --glow-inner: inset 0 0 12px var(--accent-aura-inner);
            --focus-ring: 0 0 0 2px var(--accent-aura-outer), 0 0 0 1px var(--accent-500);

            /* Effects */
            --blur: 3px;

            /* Typography */
            --font-sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
            --font-mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;

            /* Z */
            --z-stage: 1;
            --z-hud: 10;

            /* Semantic aliases */
            --bg-canvas: var(--c-bg-0);
            --bg-surface: var(--c-bg-1);
            --bg-control: var(--c-bg-2);
            --text-strong: var(--c-text-strong);
            --text-heading: var(--c-text-heading);
            --text-subtle: var(--c-text-subtle);
            --text-dim: var(--c-text-dim);

            /* HUD */
            --hud-border: 1px solid color-mix(in oklab, var(--accent-500) 35%, transparent);
            --hud-bg: linear-gradient(180deg,
                    color-mix(in oklab, var(--c-bg-1) 78%, transparent),
                    color-mix(in oklab, var(--c-bg-1) 58%, transparent));
            --hud-text: var(--accent-200);
            --hud-key: var(--accent-300);
        }

        /* =============== THEMES (Hue-only overrides) ===============
   Use one of: theme-cyan | theme-magenta | theme-amber | theme-lime
   You can add more by changing only HSL (hue + optional s/l).
*/
        /* THEMES (apply to html or #app) */
        html.theme-cyan,
        #app.theme-cyan {
            --accent-h: 170;
            --accent-s: 100%;
            --accent-l: 64%;
        }

        html.theme-magenta,
        #app.theme-magenta {
            --accent-h: 308;
            --accent-s: 95%;
            --accent-l: 64%;
        }

        html.theme-amber,
        #app.theme-amber {
            --accent-h: 44;
            --accent-s: 100%;
            --accent-l: 60%;
        }

        html.theme-lime,
        #app.theme-lime {
            --accent-h: 95;
            --accent-s: 92%;
            --accent-l: 62%;
        }

        /* =============== BASE =============== */
        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg-canvas);
            color: var(--text-strong);
            font-family: var(--font-sans);
        }

        #app {
            position: fixed;
            inset: 0;
            display: grid;
            grid-template-columns: var(--panel-w) 1fr;
            grid-template-rows: auto 1fr;
            grid-template-areas: "header header" "panel stage";
        }

        /* =============== HEADER =============== */
        header {
            grid-area: header;
            display: flex;
            gap: var(--s-4);
            align-items: center;
            padding: .6rem var(--s-5);
            background:
                linear-gradient(180deg, color-mix(in oklab, var(--accent-500) 8%, transparent), transparent);
            border-bottom: var(--bd-weak);
            box-shadow: 0 1px 0 color-mix(in oklab, var(--accent-500) 10%, transparent);
        }

        header h1 {
            font-size: 1rem;
            letter-spacing: .06em;
            margin: 0;
            color: var(--text-heading);
            font-weight: 600;
        }

        /* =============== SIDE PANEL =============== */
        #panel {
            grid-area: panel;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 12px 16px 12px 12px;
            /* add right padding */
            box-sizing: border-box;
            background: var(--bg-surface);
            min-width: var(--panel-w);
            max-width: var(--panel-w);
            box-shadow: var(--shadow-inset);
        }

        /* Scrollbars (WebKit) */
        #panel::-webkit-scrollbar {
            width: 12px;
        }

        #panel::-webkit-scrollbar-track {
            background: color-mix(in oklab, var(--bg-surface) 92%, black);
            border-left: 1px solid var(--c-line);
        }

        #panel::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg,
                    var(--accent-700),
                    var(--accent-500));
            border-radius: var(--r-2);
            border: 2px solid var(--bg-surface);
            box-shadow: 0 0 6px color-mix(in oklab, var(--accent-500) 25%, transparent);
        }

        #panel::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, var(--accent-600), var(--accent-400));
        }

        /* Scrollbars (Firefox) */
        #panel {
            scrollbar-width: thin;
            scrollbar-color: var(--accent-600) var(--bg-surface);
        }


        .section {
            margin-bottom: 12px;
            border: var(--bd-weak);
            border-radius: var(--r-3);
            background: color-mix(in oklab, var(--bg-surface) 92%, black 8%);
            box-shadow: 0 0 0 1px color-mix(in oklab, var(--accent-500) 6%, transparent);
        }

        .section>h2 {
            margin: 0;
            font-size: .9rem;
            padding: .55rem var(--s-3);
            color: var(--text-subtle);
            border-bottom: 1px dashed color-mix(in oklab, var(--accent-500) 18%, var(--c-line));
        }

        /* =============== FORMS (Unified Controls) =============== */
        .form {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px 10px;
            align-items: center;
            padding: var(--s-2) var(--s-3);
        }

        .row {
            display: flex;
            gap: .4rem;
            align-items: center;
            flex-wrap: wrap;
        }

        label {
            font-size: .82rem;
            color: var(--text-subtle);
        }

        select,
        input[type="range"],
        input[type="color"],
        input[type="text"],
        input[type="number"],
        .btn {
            width: 100%;
            box-sizing: border-box;
        }

        /* Inputs: base */
        select,
        input[type="text"],
        input[type="number"] {
            appearance: none;
            background: var(--bg-control);
            color: var(--text-strong);
            border: var(--bd-strong);
            padding: .45rem .55rem;
            border-radius: var(--r-2);
            font-weight: 600;
            transition: box-shadow .15s ease, border-color .15s ease;
        }

        select:hover,
        input[type="text"]:hover,
        input[type="number"]:hover {
            border-color: color-mix(in oklab, var(--accent-500) 22%, var(--c-line-strong));
        }

        select:focus-visible,
        input[type="text"]:focus-visible,
        input[type="number"]:focus-visible {
            outline: none;
            box-shadow: var(--focus-ring);
            border-color: var(--accent-500);
        }

        /* Color input */
        input[type="color"] {
            height: 34px;
            padding: .2rem;
            border-radius: var(--r-2);
            background: linear-gradient(180deg, var(--bg-control), color-mix(in oklab, var(--bg-control) 85%, black));
            border: var(--bd-strong);
        }

        input[type="color"]:focus-visible {
            outline: none;
            box-shadow: var(--focus-ring);
        }

        /* Range: track/thumb themed */
        input[type="range"] {
            appearance: none;
            height: 30px;
            padding: 0;
            background: transparent;
        }

        input[type="range"]:focus-visible {
            outline: none;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            height: 6px;
            border-radius: 999px;
            background:
                linear-gradient(90deg,
                    color-mix(in oklab, var(--accent-500) 22%, transparent),
                    color-mix(in oklab, var(--accent-500) 8%, transparent));
            border: 1px solid color-mix(in oklab, var(--accent-500) 25%, var(--c-line-strong));
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            margin-top: -6px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, var(--accent-300), var(--accent-500));
            border: 1px solid var(--accent-700);
            box-shadow: var(--glow-outer), 0 0 0 1px color-mix(in oklab, var(--accent-500) 35%, transparent);
        }

        input[type="range"]::-moz-range-track {
            height: 6px;
            border-radius: 999px;
            background:
                linear-gradient(90deg,
                    color-mix(in oklab, var(--accent-500) 22%, transparent),
                    color-mix(in oklab, var(--accent-500) 8%, transparent));
            border: 1px solid color-mix(in oklab, var(--accent-500) 25%, var(--c-line-strong));
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, var(--accent-300), var(--accent-500));
            border: 1px solid var(--accent-700);
            box-shadow: var(--glow-outer), 0 0 0 1px color-mix(in oklab, var(--accent-500) 35%, transparent);
        }

        /* Buttons */
        .btn {
            appearance: none;
            background:
                linear-gradient(180deg,
                    color-mix(in oklab, var(--bg-control) 92%, black),
                    color-mix(in oklab, var(--bg-control) 84%, black));
            color: var(--text-strong);
            border: var(--bd-strong);
            padding: .5rem var(--s-3);
            border-radius: var(--r-3);
            font-weight: 700;
            cursor: pointer;
            width: auto;
            transition: box-shadow .15s ease, border-color .15s ease, transform .05s ease;
        }

        .btn:hover {
            border-color: color-mix(in oklab, var(--accent-500) 30%, var(--c-text-strong) 0%);
            box-shadow: 0 0 0 2px color-mix(in oklab, var(--accent-500) 18%, transparent), var(--glow-outer);
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn.primary {
            border-color: color-mix(in oklab, var(--accent-500) 35%, var(--c-line-strong));
            background:
                linear-gradient(180deg, var(--accent-700), var(--accent-500));
            color: #061417;
            text-shadow: 0 1px 0 color-mix(in oklab, white 20%, transparent);
        }

        /* Helpers */
        .full {
            grid-column: 1 / -1;
        }

        .theme-label {
            font-size: .85rem;
            color: var(--text-subtle);
            margin-right: .5rem;
        }

        .theme-dropdown {
            appearance: none;
            background: var(--bg-control);
            color: var(--text-strong);
            border: var(--bd-strong);
            border-radius: var(--r-2);
            padding: .4rem .8rem;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 0 4px color-mix(in oklab, var(--accent-500) 15%, transparent);
            transition: box-shadow .15s ease, border-color .15s ease;
        }

        .theme-dropdown:hover {
            border-color: color-mix(in oklab, var(--accent-500) 30%, var(--c-line-strong));
            box-shadow: 0 0 8px color-mix(in oklab, var(--accent-500) 25%, transparent);
        }

        .theme-dropdown:focus-visible {
            outline: none;
            box-shadow: var(--focus-ring);
        }

        /* =============== STAGE =============== */
        #stageWrap {
            grid-area: stage;
            position: relative;
        }

        #bgOverlay {
            position: absolute;
            inset: 0;
            z-index: 0;
        }

        #stage {
            position: absolute;
            inset: 0;
            z-index: var(--z-stage);
        }

        /* =============== FOOTER =============== */
        footer {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--s-4);
            padding: .4rem .6rem;
            color: var(--text-dim);
            font-size: .85rem;
            background: rgba(0, 0, 0, .25);
            border: var(--bd-weak);
            border-radius: var(--r-3);
        }

        .kbd {
            background: var(--bg-surface);
            border: var(--bd-strong);
            padding: .15rem .35rem;
            border-radius: var(--r-1);
            font-size: .85em;
            color: var(--text-strong);
        }

        /* =============== HUD (Debug Overlay) =============== */
        #hud {
            position: absolute;
            top: 42px;
            left: var(--panel-w);
            max-width: 380px;
            max-height: 60vh;
            overflow: auto;
            padding: 10px 12px;
            border: var(--hud-border);
            background: var(--hud-bg);
            box-shadow: var(--glow-outer), var(--glow-inner);
            border-radius: var(--r-2);
            font: 12px/1.35 var(--font-mono);
            color: var(--hud-text);
            letter-spacing: .2px;
            backdrop-filter: blur(var(--blur));
            display: none;
            z-index: var(--z-hud);
        }

        #hud .hdr {
            color: var(--accent-200);
            text-transform: uppercase;
            font-weight: 700;
            margin: 8px 0 4px;
            border-bottom: 1px dashed color-mix(in oklab, var(--accent-500) 35%, transparent);
            padding-bottom: 2px;
        }

        #hud .k {
            color: var(--hud-key);
        }

        #hud .v {
            color: #e1fff7;
        }

        #hud .warn {
            color: #ffde69;
        }

        #hud .err {
            color: #ff8a8a;
        }

        /* =============== Focus/Reduce Motion =============== */
        *:focus-visible {
            outline: none;
            box-shadow: var(--focus-ring);
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                transition: none !important;
                animation: none !important;
            }
        }
    </style>

    <!-- Import map for bare specifier "three" -->
    <script type="importmap">
  { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
  </script>
</head>

<body>
    <div id="app">
        <header>
            <h1>Geometric Bonsai ‚Äî Ikebana Style</h1>
            <div style="margin-left:auto;">
                <select id="themeSelect" class="theme-dropdown">
                    <option value="cyan">Cyan</option>
                    <option value="magenta">Magenta</option>
                    <option value="amber">Amber</option>
                    <option value="lime">Lime</option>
                </select>
            </div>
        </header>

        <aside id="panel">
            <div class="section">
                <h2>Scene</h2> <!-- Debug HUD toggle -->
                <div class="form">
                    <!-- Cyberpunk HUD overlay -->
                    <label>Display Debug</label>
                    <input id="debugToggle" type="checkbox">
                    <div id="hud" aria-hidden="true"></div>
                    <label>Background</label>
                    <input id="bgColor" type="color" value="#0e1115" />
                    <label>Texture</label>
                    <select id="bgTex">
                        <option value="solid">Solid</option>
                        <option value="grain">Grain</option>
                        <option value="gradient">Gradient</option>
                        <option value="paper">Paper</option>
                    </select>
                    <label>Key</label>
                    <input id="keyLight" type="range" min="0" max="5" step="0.01" value="0.55" />
                    <label>Ambient</label>
                    <input id="hemiLight" type="range" min="0" max="5" step="0.01" value="0.9" />
                    <label>Exposure</label>
                    <input id="exposure" type="range" min="0.5" max="2.5" step="0.01" value="1" />
                    <div class="full row">
                        <button id="frame" class="btn">Frame</button>
                        <button id="shot" class="btn">üì∏ Screenshot</button>
                        <button id="newSeed" class="btn">New Seed</button>
                        <span>Seed: <span id="seedLabel" class="kbd">‚Äî</span></span>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>Species</h2>
                <div class="form">
                    <label>Type</label>
                    <select id="treeType">
                        <option value="magnolia">Magnolia (petals, arching)</option>
                        <option value="maple">Maple (broad, lobed)</option>
                        <option value="pine">Pine (upright, whorled)</option>
                        <option value="olive">Olive (compact, slabs)</option>
                        <option value="juniper">Juniper (windswept)</option>
                        <option value="ginkgo">Ginkgo (tiered fans)</option>
                    </select>
                    <label>Levels</label>
                    <input id="levels" type="range" min="3" max="10" step="1" value="6" />
                    <label>Curvature</label>
                    <input id="curvature" type="range" min="0" max="1" step="0.01" value="0.55" />
                    <label>Uniformity</label>
                    <input id="uniformity" type="range" min="0" max="1" step="0.01" value="0.6" />
                    <label>Spread</label>
                    <input id="spread" type="range" min="0.3" max="1.2" step="0.01" value="0.75" />
                    <label>Up-Bias</label>
                    <input id="upBias" type="range" min="0" max="1" step="0.01" value="0.3" />
                </div>
            </div>

            <div class="section">
                <h2>Branchlets</h2>
                <div class="form">
                    <label>Branch Color</label>
                    <input id="branchColor" type="color" value="#3b2d44">
                    <label>Leaf Color</label>
                    <input id="leafColor" type="color" value="#2d6e52">
                    <label>Depth</label>
                    <input id="bDepth" type="range" min="1" max="4" step="1" value="3" />
                    <label>Per-level Min</label>
                    <input id="bMin" type="range" min="1" max="6" step="1" value="2" />
                    <label>Per-level Max</label>
                    <input id="bMax" type="range" min="1" max="8" step="1" value="3" />
                    <label>Branch Length</label>
                    <input id="bLen" type="range" min="0.5" max="1.8" step="0.01" value="1" />
                    <label>Terminal Density</label>
                    <input id="density" type="range" min="0.3" max="3" step="0.01" value="1" />
                    <label>Leaf Spread</label>
                    <input id="leafSpread" type="range" min="0.3" max="2.5" step="0.01" value="1" />
                    <label>Leaf Type</label>
                    <select id="leafType">
                        <option value="diamond">Diamond</option>
                        <option value="needle">Needle</option>
                        <option value="slab">Slab</option>
                        <option value="sphere">Sphere</option>
                        <option value="triangle">Triangle</option>
                        <option value="cone">Cone</option>
                        <option value="teardrop">Teardrop</option>
                        <option value="half">Half‚Äëcircle</option>
                        <option value="crescent">Crescent</option>
                        <option value="petal">Petal (flower)</option>
                    </select>
                    <label>Plumage</label>
                    <select id="plumage">
                        <option value="random">Random</option>
                        <option value="upward">Upward</option>
                        <option value="radial">Radial</option>
                        <option value="wind-left">Wind ‚Üí</option>
                        <option value="wind-right">Wind ‚Üê</option>
                    </select>
                </div>
            </div>

            <div class="section">
                <h2>Vessel</h2>
                <div class="form">
                    <label>Type</label>
                    <label>Color</label>
                    <input id="vesselColor" type="color" value="#a5b2bd" />
                    <select id="vesselType">
                        <option value="glass-cylinder">Glass Cylinder</option>
                        <option value="shallow-bowl">Shallow Bowl</option>
                        <option value="faceted">Faceted Prism</option>
                        <option value="stone-disc">Stone Disc</option>
                    </select>
                    <label>Diameter</label>
                    <input id="vesselDia" type="range" min="0.8" max="2.4" step="0.01" value="1.2" />
                    <label>Depth</label>
                    <input id="vesselDepth" type="range" min="0.2" max="2.5" step="0.01" value="1.6" />
                    <div class="full row"><button id="applyVessel" class="btn">Apply Vessel</button></div>
                </div>
            </div>

            <div class="section">
                <h2>Render & Appearance</h2>
                <div class="form">
                    <label>Auto rotate</label>
                    <select id="autoRotate">
                        <option value="off">Off</option>
                        <option value="on" selected>On</option>
                    </select>
                    <button id="autoBtn" class="btn">‚è∏ Pause</button>
                    <input id="autoSpeed" type="range" min="-4" max="4" step="0.01" value="0.8" />
                    <button id="rotLeft" class="btn">‚ü≤ Left</button>
                    <button id="rotRight" class="btn">‚ü≥ Right</button>
                    <label>Wireframe</label>
                    <select id="wireToggle">
                        <option value="off">Off</option>
                        <option value="on">On</option>
                    </select>
                    <label>Render Mode</label>
                    <select id="renderMode">
                        <option value="toon">Toon</option>
                        <option value="sketchy">Sketchy</option>
                        <option value="metallic">Metallic</option>
                        <option value="holographic">Holographic</option>
                        <option value="emissive">Emissive</option>
                    </select>
                    <label>Emissive Color</label>
                    <input id="emissiveColor" type="color" value="#94e3ff">
                    <label>Emissive Strength</label>
                    <input id="emissiveStrength" type="range" min="0" max="1" step="0.01" value="0.5" />
                </div>

            </div>
        </aside>

        <div id="stageWrap">
            <div id="bgOverlay"></div>
            <div id="stage"></div>
            <footer>
                <div>Tip: drag to orbit ¬∑ wheel/pinch to zoom</div>
                <div>Press <span class="kbd">Frame</span> to refit</div>
            </footer>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

        // --- UI refs ---
        const $ = (id) => document.getElementById(id);
        const stage = $('stage');
        const bgOverlay = $('bgOverlay');
        const seedLabel = $('seedLabel');
        const treeType = $('treeType');
        const levels = $('levels');
        const curvature = $('curvature');
        const uniformity = $('uniformity');
        const spread = $('spread');
        const upBias = $('upBias');
        const bDepth = $('bDepth');
        const bMin = $('bMin');
        const bMax = $('bMax');
        const bLen = $('bLen');
        const density = $('density');
        const leafSpread = $('leafSpread');
        const leafType = $('leafType');
        const plumage = $('plumage');
        const vesselType = $('vesselType');
        const vesselDia = $('vesselDia');
        const vesselDepth = $('vesselDepth');
        const vesselColor = $('vesselColor');
        const applyVessel = $('applyVessel');
        const bgColor = $('bgColor');
        const bgTex = $('bgTex');
        const keyLightUI = $('keyLight');
        const hemiLightUI = $('hemiLight');
        const exposureUI = $('exposure');
        const frameBtn = $('frame');
        const shotBtn = $('shot');
        const newSeedBtn = $('newSeed');
        const wireToggle = $('wireToggle');
        const renderMode = $('renderMode');
        const emissiveStrengthUI = document.getElementById('emissiveStrength');
        const autoBtn = document.getElementById('autoBtn');
        const autoRotate = $('autoRotate');
        const autoSpeedUI = $('autoSpeed');
        const branchColorUI = $('branchColor');
        const leafColorUI = $('leafColor');
        const emissiveColorUI = $('emissiveColor');
        [branchColorUI, leafColorUI, emissiveColorUI].forEach(el => el && el.addEventListener('input', applyRenderStyle));

        const MAX_GLOBAL_LEAVES = 1000;   // safety cap
        let globalLeafCount = 0;

        let spinPivotY = 0;    // world Y of vessel base

        let frameNo = 0;
        let fpsEMA = 0;          // exponential moving avg
        const FPS_ALPHA = 0.12;  // smoothing factor

        const rotLeft = $('rotLeft');
        const rotRight = $('rotRight');

        // --- Scene ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(38, 1, 0.1, 200);
        camera.position.set(6, 4.2, 11);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
        renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
        renderer.outputColorSpace = THREE.SRGBColorSpace;     // r160 uses outputColorSpace
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = parseFloat(exposureUI.value);
        stage.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.08;
        controls.minDistance = 4; controls.maxDistance = 30;
        controls.maxPolarAngle = Math.PI * 0.95; controls.target.set(0, 0, 0);


        const hemi = new THREE.HemisphereLight(0xf4efe8, 0x0b0f12, parseFloat(hemiLightUI.value));
        const dir = new THREE.DirectionalLight(0xffffff, parseFloat(keyLightUI.value)); dir.position.set(3, 5, 4);
        scene.add(hemi, dir);

        const root = new THREE.Group(); scene.add(root);
        let ike = new THREE.Group(); root.add(ike);
        let vesselGroup = null, treeGroup = null, sketchOverlay = null;
        let didInitialFrame = false;

        // --- Smooth autorotation & manual spin ---
        const clock = new THREE.Clock();
        let autoOn = true;              // default ON
        let holdSpin = 0;               // -1 = right, +1 = left while pressed
        const AUTO_BASE = 0.8;          // base radians/sec scale for speed slider

        const debugToggle = $('debugToggle');
        const hud = $('hud');

        // handy formatters
        const d = (n) => Number.isFinite(n) ? n.toFixed(3) : 'NaN';
        const deg = (r) => d(THREE.MathUtils.radToDeg(r));
        const v3 = (v) => `${d(v.x)}, ${d(v.y)}, ${d(v.z)}`;
        const eulerDeg = (e) => `${deg(e.x)}, ${deg(e.y)}, ${deg(e.z)}`;

        function renderHUD() {
            if (!debugToggle || !hud) return;
            const on = !!debugToggle.checked;
            hud.style.display = on ? 'block' : 'none';
            if (!on) return;

            // gather data
            const cam = camera;
            const tgt = controls.target;
            const ikeRot = ike.rotation;
            const ikePos = ike.position;
            const ikeScale = ike.scale;

            const ems = emissiveStrengthUI ? parseFloat(emissiveStrengthUI.value) : 0;
            const w = wireToggle ? (wireToggle.value === 'on') : false;

            const ri = renderer.info;

            // counts come from your generators:
            // lastBranchSegments, lastTerminalPieces, globalLeafCount
            // seed from currentSeed

            // vessel values
            const vType = vesselType ? vesselType.value : '';
            const vDia = vesselDia ? parseFloat(vesselDia.value) : 0;
            const vDep = vesselDepth ? parseFloat(vesselDepth.value) : 0;

            // tree settings
            const tSet = {
                type: treeType.value, levels: levels.value,
                bDepth: bDepth.value, bMin: bMin.value, bMax: bMax.value, bLen: bLen.value,
                curvature: curvature.value, uniformity: uniformity.value, upBias: upBias.value, spread: spread.value,
                density: density.value, leafSpread: leafSpread.value, leafType: leafType.value, plumage: plumage.value
            };

            const lines = [];
            lines.push(`<div class="hdr">runtime</div>`);
            lines.push(`<div><span class="k">frame</span> <span class="v">${frameNo}</span>  <span class="k">fps~</span> <span class="v">${fpsEMA.toFixed(1)}</span></div>`);
            lines.push(`<div><span class="k">auto</span> <span class="v">${autoOn ? 'on' : 'off'}</span>  <span class="k">speed</span> <span class="v">${autoSpeedUI ? autoSpeedUI.value : '‚Äî'}</span></div>`);
            lines.push(`<div class="hdr">camera</div>`);
            lines.push(`<div><span class="k">pos</span> <span class="v">${v3(cam.position)}</span></div>`);
            lines.push(`<div><span class="k">rot(deg)</span> <span class="v">${eulerDeg(cam.rotation)}</span></div>`);
            lines.push(`<div><span class="k">target</span> <span class="v">${v3(tgt)}</span></div>`);
            lines.push(`<div class="hdr">object (ike)</div>`);
            lines.push(`<div><span class="k">pos</span> <span class="v">${v3(ikePos)}</span></div>`);
            lines.push(`<div><span class="k">rot(deg)</span> <span class="v">${eulerDeg(ikeRot)}</span></div>`);
            lines.push(`<div><span class="k">scale</span> <span class="v">${v3(ikeScale)}</span></div>`);
            lines.push(`<div><span class="k">seed</span> <span class="v">${currentSeed}</span></div>`);
            lines.push(`<div class="hdr">vessel</div>`);
            lines.push(`<div><span class="k">type</span> <span class="v">${vType}</span></div>`);
            lines.push(`<div><span class="k">dia</span> <span class="v">${d(vDia)}</span>  <span class="k">depth</span> <span class="v">${d(vDep)}</span></div>`);
            lines.push(`<div class="hdr">tree</div>`);
            lines.push(`<div><span class="k">type</span> <span class="v">${tSet.type}</span>  <span class="k">levels</span> <span class="v">${tSet.levels}</span></div>`);
            lines.push(`<div><span class="k">branch</span> <span class="v">depth ${tSet.bDepth}, min ${tSet.bMin}, max ${tSet.bMax}, len ${tSet.bLen}</span></div>`);
            lines.push(`<div><span class="k">shape</span> <span class="v">curv ${tSet.curvature}, uni ${tSet.uniformity}, upBias ${tSet.upBias}, spread ${tSet.spread}</span></div>`);
            lines.push(`<div><span class="k">leaves</span> <span class="v">${tSet.leafType}, spread ${tSet.leafSpread}, density ${tSet.density}, plumage ${tSet.plumage}</span></div>`);
            lines.push(`<div class="hdr">render</div>`);
            lines.push(`<div><span class="k">mode</span> <span class="v">${renderMode.value}</span>  <span class="k">wire</span> <span class="v">${w ? 'on' : 'off'}</span>  <span class="k">emiss</span> <span class="v">${ems}</span></div>`);
            lines.push(`<div class="hdr">counts</div>`);
            lines.push(`<div><span class="k">segments</span> <span class="v">${lastBranchSegments}</span>  <span class="k">terminals</span> <span class="v">${lastTerminalPieces}</span>  <span class="k">globalLeaves</span> <span class="v">${globalLeafCount}</span></div>`);

            lines.push(`<div class="hdr">gpu</div>`);
            lines.push(`<div><span class="k">calls</span> <span class="v">${ri.render.calls}</span>  <span class="k">tri</span> <span class="v">${ri.render.triangles}</span>  <span class="k">points</span> <span class="v">${ri.render.points}</span></div>`);


            hud.innerHTML = lines.join('');
        }

        function spinBy(radPerSec, dt) {
            if (!radPerSec || !dt) return;
            // rotate the whole arrangement around Y at spin pivot
            // keep rotation ‚Äúin place‚Äù visually relative to pivot Y
            ike.rotation.y += radPerSec * dt;
        }

        function applySpins(dt) {
            const uiSpeed = (autoSpeedUI) ? parseFloat(autoSpeedUI.value) : 0.8;
            if (autoOn && uiSpeed !== 0) spinBy(uiSpeed * AUTO_BASE, dt);
            if (holdSpin !== 0) spinBy(holdSpin * 1.2, dt);
        }

        // convenience from UI
        function setAutoRotate(on) {
            autoOn = !!on;                            // our smooth rot flag
            controls.autoRotate = autoOn;             // mirror for tests/UI
            if (autoRotate) autoRotate.value = autoOn ? 'on' : 'off';
            if (autoBtn) autoBtn.textContent = autoOn ? '‚è∏ Pause' : '‚ñ∂ Play';
        }

        function onResize() {
            const rect = stage.getBoundingClientRect();
            const w = Math.max(1, rect.width);
            const h = Math.max(1, rect.height);
            renderer.setSize(w, h, false);
            camera.aspect = w / h; camera.updateProjectionMatrix();
        }
        window.addEventListener('resize', onResize); onResize();

        // RNG
        function mulberry32(a) { return function () { let t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; }; }
        const seeded = (s) => mulberry32(s >>> 0);
        const rr = (r, min, max) => min + r() * (max - min);

        // Materials (DoubleSide to avoid backface holes)
        const DS = THREE.DoubleSide;
        const mats = {
            branch: new THREE.MeshToonMaterial({ color: 0x3b2d44, side: DS }),
            leaf: new THREE.MeshToonMaterial({ color: 0x2d6e52, transparent: true, opacity: 0.95, side: DS }),
            petal: new THREE.MeshToonMaterial({ color: 0xf3e7da, transparent: true, opacity: 0.98, side: DS }),
            accent: new THREE.MeshToonMaterial({ color: 0xd6b36a, transparent: true, opacity: 0.95, side: DS }),
            glass: new THREE.MeshPhysicalMaterial({ color: 0xa5b2bd, metalness: 0, roughness: 0.2, transmission: 0.9, ior: 1.2, thickness: 0.8, transparent: true, opacity: 0.85, side: DS }),
            water: new THREE.MeshPhysicalMaterial({ color: 0x5b7a86, metalness: 0, roughness: 0.4, transmission: 0.9, ior: 1.33, thickness: 0.2, transparent: true, opacity: 0.6, side: DS }),
            stone: new THREE.MeshStandardMaterial({ color: 0x545a5f, roughness: 0.9, metalness: 0.0, side: DS })
        };

        // Species presets
        const PRESETS = {
            magnolia: { spread: 0.6, upBias: 0.2, lenFalloff: 0.72, leaves: 'petal', trunk: 'arch', colors: { branch: 0x3b2d44, leaf: 0xf3e7da } },
            maple: { spread: 0.9, upBias: 0.15, lenFalloff: 0.70, leaves: 'diamond', trunk: 'splay', colors: { branch: 0x3b2d44, leaf: 0xd44a2f } },
            pine: { spread: 0.5, upBias: 0.6, lenFalloff: 0.76, leaves: 'needle', trunk: 'upright', branchPattern: 'whorl', colors: { branch: 0x2a3a2c, leaf: 0x1d4228 } },
            olive: { spread: 0.65, upBias: 0.4, lenFalloff: 0.74, leaves: 'slab', trunk: 'compact', colors: { branch: 0x403e3a, leaf: 0x6e7b64 } },
            juniper: { spread: 0.55, upBias: 0.45, lenFalloff: 0.75, leaves: 'teardrop', trunk: 'windswept', colors: { branch: 0x2e3a3f, leaf: 0x547b7c } },
            ginkgo: { spread: 0.8, upBias: 0.25, lenFalloff: 0.71, leaves: 'half', trunk: 'tiered', branchPattern: 'tiers', colors: { branch: 0x3b2d44, leaf: 0xe8b736 } }
        };

        let currentSeed = (Math.random() * 0xFFFFFFFF) >>> 0;
        let lastTerminalPieces = 0, lastBranchSegments = 0;

        function setSeed(seed) { currentSeed = seed >>> 0; seedLabel.textContent = String(currentSeed); }

        // Background textures
        function applyBackground() {
            const color = bgColor.value;
            bgOverlay.style.backgroundImage = '';
            if (bgTex.value === 'solid') {
                bgOverlay.style.background = color;
            } else if (bgTex.value === 'grain') {
                bgOverlay.style.background = `${color}`;
                bgOverlay.style.backgroundImage = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><filter id="n"><feTurbulence baseFrequency="0.8" type="fractalNoise" numOctaves="2"/><feColorMatrix type="saturate" values="0"/></filter><rect width="100" height="100" filter="url(%23n)" opacity="0.15"/></svg>')`;
                bgOverlay.style.backgroundBlendMode = 'overlay';
            } else if (bgTex.value === 'gradient') {
                bgOverlay.style.background = `radial-gradient(1000px 800px at 70% 25%, ${color}, #0a0e12)`;
            } else if (bgTex.value === 'paper') {
                bgOverlay.style.background = color;
                bgOverlay.style.backgroundImage = `linear-gradient(rgba(255,255,255,.03) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,.02) 1px, transparent 1px)`;
                bgOverlay.style.backgroundSize = '6px 6px, 6px 6px';
            }
        }

        function makeVessel(type, dia = 1.2, depth = 1.6) {
            if (vesselGroup) { ike.remove(vesselGroup); vesselGroup.traverse(o => { if (o.geometry) o.geometry.dispose(); }); }
            const g = new THREE.Group(); g.position.y = -1.6; vesselGroup = g; ike.add(g);
            const tint = new THREE.Color(vesselColor.value);
            mats.glass.color.copy(tint); mats.stone.color.copy(tint);
            if (type === 'glass-cylinder') {
                const outer = new THREE.Mesh(new THREE.CylinderGeometry(dia * 0.9, dia * 0.9, depth, 36, 1, true), mats.glass);
                const inner = new THREE.Mesh(new THREE.CylinderGeometry(dia * 0.82, dia * 0.82, depth * 0.92, 36, 1, true), mats.glass);
                const water = new THREE.Mesh(new THREE.CylinderGeometry(dia * 0.8, dia * 0.8, Math.max(0.2, depth * 0.45), 36), mats.water); water.position.y = -depth * 0.25;
                g.add(outer, inner, water);
            } else if (type === 'shallow-bowl') {
                const bowl = new THREE.Mesh(new THREE.CylinderGeometry(dia * 1.3, dia * 1.5, Math.max(0.25, depth * 0.35), 24, 1, true), mats.glass);
                bowl.position.y = -Math.max(0.05, depth * 0.1); g.add(bowl);
                const pool = new THREE.Mesh(new THREE.CylinderGeometry(dia * 1.2, dia * 1.2, Math.max(0.1, depth * 0.12), 24), mats.water); pool.position.y = -Math.max(0.08, depth * 0.18); g.add(pool);
            } else if (type === 'faceted') {
                const prism = new THREE.Mesh(new THREE.DodecahedronGeometry(Math.max(0.6, dia * 0.7), 0), mats.glass); prism.position.y = 0.1; g.add(prism);
            } else if (type === 'stone-disc') {
                const disc = new THREE.Mesh(new THREE.CylinderGeometry(dia * 1.4, dia * 1.4, Math.max(0.2, depth * 0.16), 36), mats.stone); disc.position.y = -depth * 0.6; g.add(disc);
            }
            return g;
        }

        function updateSpinPivotFromVessel() {
            if (!vesselGroup) return;
            const box = new THREE.Box3().setFromObject(vesselGroup);
            spinPivotY = box.min.y; // used for any future pivot math if needed
        }

        function orbitTargetToVesselBase() {
            if (!vesselGroup) return;
            const box = new THREE.Box3().setFromObject(vesselGroup);
            const baseY = box.min.y;
            controls.target.set(0, baseY, 0);
        }

        // Render styles (tree only)
        function applyRenderStyle() {
            const mode = renderMode.value;
            const wire = wireToggle.value === 'on';
            const branchColor = new THREE.Color(branchColorUI ? branchColorUI.value : mats.branch.color);
            const leafColor = new THREE.Color(leafColorUI ? leafColorUI.value : mats.leaf.color);
            const petalColor = mats.petal.color.clone();
            const emissiveCol = new THREE.Color(emissiveColorUI ? emissiveColorUI.value : leafColor);

            const setMat = (mesh, kind) => {
                let mat;
                if (mode === 'metallic') {
                    mat = new THREE.MeshStandardMaterial({
                        color: kind === 'branch' ? branchColor : (kind === 'petal' ? petalColor : leafColor),
                        metalness: 0.85, roughness: 0.25, wireframe: wire, side: DS
                    });
                }
                else if (mode === 'holographic') {
                    const base = new THREE.MeshPhysicalMaterial({
                        color: kind === 'branch' ? branchColor : (kind === 'petal' ? petalColor : leafColor),
                        metalness: 0.2, roughness: 0.1, transmission: 0.4,
                        transparent: true, opacity: 0.9, wireframe: wire, side: DS
                    });
                    base.onBeforeCompile = (shader) => {
                        shader.fragmentShader = shader.fragmentShader.replace('#include <output_fragment>', `
                        float fres = pow(1.0 - dot(normalize(vViewPosition), normalize(normal)), 2.0);
                        vec3 holo = mix(gl_FragColor.rgb, vec3(0.6,0.8,1.0), fres*0.9);
                        gl_FragColor = vec4(holo, gl_FragColor.a);
                    `);
                    };
                    mat = base;
                }
                else if (mode === 'emissive') {
                    mat = new THREE.MeshStandardMaterial({
                        color: (kind === 'branch' ? branchColor : (kind === 'petal' ? petalColor : leafColor)),
                        emissive: (kind === 'branch' ? branchColor : (kind === 'petal' ? petalColor : emissiveCol)),
                        emissiveIntensity: parseFloat(emissiveStrengthUI.value),
                        metalness: 0.0, roughness: 0.6, wireframe: wire, side: DS
                    });
                }
                else { // toon default
                    mat = (kind === 'petal') ? mats.petal.clone()
                        : (kind === 'branch' ? mats.branch.clone() : mats.leaf.clone());
                    mat.wireframe = wire; mat.side = DS;
                }
                mesh.material = mat;
            };


            if (treeGroup) {
                treeGroup.traverse(o => { if (o.isMesh) { const kind = o.userData.kind || 'branch'; setMat(o, kind); } });
            }

            if (sketchOverlay) { ike.remove(sketchOverlay); sketchOverlay.traverse(o => { if (o.geometry) o.geometry.dispose(); }); sketchOverlay = null; }
            if (mode === 'sketchy') {
                sketchOverlay = new THREE.Group();
                treeGroup.traverse(o => {
                    if (o.isMesh && o.geometry) {
                        const e = new THREE.EdgesGeometry(o.geometry, 15);
                        const lines = new THREE.LineSegments(e, new THREE.LineBasicMaterial({ color: 0x0b0b0b, transparent: true, opacity: 0.6 }));
                        lines.position.copy(o.position); lines.rotation.copy(o.rotation); lines.scale.copy(o.scale); lines.quaternion.copy(o.quaternion);
                        lines.userData.kind = 'sketch';
                        o.add(lines); sketchOverlay.add(lines);
                    }
                });
            }
        }

        function leafGeometry(kind) {
            switch (kind) {
                case 'sphere': return new THREE.IcosahedronGeometry(0.18, 0);
                case 'triangle': return new THREE.ConeGeometry(0.22, 0.32, 3);
                case 'cone': return new THREE.ConeGeometry(0.16, 0.5, 10);
                case 'diamond': return new THREE.OctahedronGeometry(0.18, 0);
                case 'slab': return new THREE.BoxGeometry(0.24, 0.08, 0.24);
                case 'needle': return new THREE.CylinderGeometry(0.02, 0.02, 0.7, 8);
                case 'half': { const pts = []; for (let i = 0; i <= 10; i++) { const a = (i / 10) * Math.PI; pts.push(new THREE.Vector2(Math.sin(a) * 0.22, Math.cos(a) * 0.22)); } return new THREE.LatheGeometry(pts, 16, 0, Math.PI); }
                case 'crescent': return new THREE.TorusGeometry(0.25, 0.06, 10, 24, Math.PI * 1.2);
                case 'teardrop': { const g = new THREE.Group(); g.add(new THREE.Mesh(new THREE.ConeGeometry(0.12, 0.5, 10))); const cap = new THREE.Mesh(new THREE.SphereGeometry(0.14, 12, 12)); cap.position.y = 0.24; g.add(cap); return g; }
                case 'petal': default: return new THREE.BoxGeometry(0.12, 0.8, 0.02);
            }
        }

        function regenerate() {
            // Snapshot camera + object transforms (to restore exactly)
            const camPos = camera.position.clone();
            const camTarget = controls.target.clone();

            // Preserve ike transform so object rotation never resets
            const ikePos = ike.position.clone();
            const ikeRot = ike.rotation.clone();
            const ikeScale = ike.scale.clone();

            // Clear children instead of replacing `ike`
            if (treeGroup) {
                ike.remove(treeGroup);
                treeGroup.traverse(o => { if (o.geometry) o.geometry.dispose(); });
                treeGroup = null;
            }
            if (vesselGroup) {
                ike.remove(vesselGroup);
                vesselGroup.traverse(o => { if (o.geometry) o.geometry.dispose(); });
                vesselGroup = null;
            }

            // Rebuild vessel + tree as children of the *same* `ike`
            makeVessel(vesselType.value, parseFloat(vesselDia.value), parseFloat(vesselDepth.value));

            // NOTE: do NOT re-center the camera target here.
            // Only recompute spin pivot, leave camera/target untouched.
            updateSpinPivotFromVessel();

            treeGroup = new THREE.Group();
            ike.add(treeGroup);

            const preset = PRESETS[treeType.value];
            mats.branch.color.set(preset.colors.branch);
            mats.leaf.color.set(preset.colors.leaf);

            const depth = parseInt(levels.value, 10);
            const sp = parseFloat(spread.value) || preset.spread;
            const up = parseFloat(upBias.value) || preset.upBias;
            const lenFall = preset.lenFalloff;
            const leavesKind = leafType.value || preset.leaves;
            const curv = parseFloat(curvature.value);
            const uni = parseFloat(uniformity.value);
            const childMin = parseInt(bMin.value, 10);
            const childMax = parseInt(bMax.value, 10);
            const depthBranches = parseInt(bDepth.value, 10);
            const branchLenMul = parseFloat(bLen.value);
            const densityMul = parseFloat(density.value);
            const leafSpreadMul = parseFloat(leafSpread.value);

            globalLeafCount = 0; // <-- reset once per generation HERE

            const r = seeded(currentSeed);

            // Trunk
            const trunkGroup = new THREE.Group(); treeGroup.add(trunkGroup);
            lastBranchSegments = 0;
            function addSegment(a, b, thickness) {
                const dir = new THREE.Vector3().subVectors(b, a); const len = dir.length(); dir.normalize();
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(thickness, thickness, len));
                mesh.userData.kind = 'branch';
                const quat = new THREE.Quaternion(); quat.setFromUnitVectors(new THREE.Vector3(0, 0, 1), dir);
                mesh.quaternion.copy(quat); mesh.position.copy(a.clone().addScaledVector(dir, len / 2));
                trunkGroup.add(mesh); lastBranchSegments++;
            }

            const pts = []; let p = new THREE.Vector3(rr(r, -0.05, 0.05), -0.9, rr(r, -0.05, 0.05));
            const upVec = new THREE.Vector3(0, 1, 0);
            let dir0 = new THREE.Vector3(rr(r, -0.1, 0.1), 1, rr(r, -0.1, 0.1)).normalize();
            let len = 2.6;
            const bendDir = (preset.trunk === 'windswept') ? new THREE.Vector3(1, 0, 0) : new THREE.Vector3(rr(r, -1, 1), 0, rr(r, -1, 1));
            bendDir.normalize().multiplyScalar(0.6 * curv);

            for (let i = 0; i < depth; i++) {
                let yawBias = bendDir.x * 0.35 + (1 - uni) * rr(r, -0.3, 0.3);
                let pitchBias = (preset.trunk === 'upright' ? 0.08 : 0.15) * curv + (1 - uni) * rr(r, -0.2, 0.2) + up * 0.05;
                if (preset.trunk === 'tiered' && i % 2 === 0) { yawBias *= 0.35; pitchBias *= 0.2; }
                if (preset.trunk === 'compact') { yawBias *= 0.5; pitchBias *= 0.5; }
                if (preset.trunk === 'splay') { yawBias += rr(r, -0.15, 0.15); }
                dir0 = dir0.clone().applyAxisAngle(upVec, yawBias).applyAxisAngle(new THREE.Vector3(1, 0, 0), pitchBias).normalize();
                const np = p.clone().addScaledVector(dir0, len);
                np.add(new THREE.Vector3(rr(r, -0.10, 0.10), rr(r, -0.05, 0.05), rr(r, -0.10, 0.10)).multiplyScalar(curv * 0.35));
                pts.push([p.clone(), np.clone(), Math.max(0.035, 0.10 * Math.pow(lenFall, i))]);
                p = np; len *= lenFall * rr(r, 0.95, 1.05);
            }
            pts.forEach(([a, b, t]) => addSegment(a, b, t));

            // Direction preferences
            function preferredDir(baseDir) {
                const mode = plumage.value;
                if (mode === 'upward') return new THREE.Vector3(0, 1, 0);
                if (mode === 'radial') return baseDir.clone();
                if (mode === 'wind-left') return new THREE.Vector3(-1, 0.2, 0).normalize();
                if (mode === 'wind-right') return new THREE.Vector3(1, 0.2, 0).normalize();
                return null;
            }

            // Foliage
            const foliageGroup = new THREE.Group(); treeGroup.add(foliageGroup);
            lastTerminalPieces = 0;
            function addTerminal(p, dir) {
                const grp = new THREE.Group();
                grp.position.copy(p);
                grp.lookAt(p.clone().add(dir));

                // Density: map [0..1] -> ~[4..22] with a gentle curve; cap globally
                const d = Math.max(0, Math.min(1.0, densityMul));
                const base = 4 + Math.round(18 * d * d); // quadratic easing; smaller at low d, ramps up smoothly
                let count = Math.min(base, MAX_GLOBAL_LEAVES - globalLeafCount);
                if (count <= 0) return;

                for (let i = 0; i < count; i++) {
                    const g = leafGeometry(leavesKind);
                    const meshOrGroup = (g.isGeometry || g.isBufferGeometry) ? new THREE.Mesh(g) : g;
                    meshOrGroup.userData.kind = (leavesKind === 'petal' ? 'petal' : 'leaf');

                    // Radial spread without geometry scaling (avoids squashing)
                    const rMax = 0.28 * leafSpreadMul;
                    const a = rr(r, 0, Math.PI * 2);
                    const rad = rr(r, 0.15 * leafSpreadMul, rMax);
                    const yJit = rr(r, -0.12, 0.12);
                    meshOrGroup.position.set(Math.cos(a) * rad, yJit, Math.sin(a) * rad);

                    // (keeping your random rotations)
                    if (meshOrGroup.rotation) {
                        meshOrGroup.rotation.set(rr(r, -0.2, 0.2), rr(r, -Math.PI, Math.PI), rr(r, -0.2, 0.2));
                    }

                    grp.add(meshOrGroup);
                    lastTerminalPieces++;
                    globalLeafCount++;             // <‚Äî increment global cap
                    if (globalLeafCount >= MAX_GLOBAL_LEAVES) break;
                }

                treeGroup.add(grp);
            }

            // Recursive branching
            function grow(origin, dirBase, levelIdx, depthLeft) {
                const pref = preferredDir(dirBase);
                const yaw = rr(r, -sp, sp) * Math.PI * 0.6 * (1 - uni);
                const pitch = rr(r, -0.2, 0.2) * Math.PI * 0.3 * (1 - uni) - rr(r, 0, up) * 0.2;
                let dir = dirBase.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw).applyAxisAngle(new THREE.Vector3(1, 0, 0), pitch);
                if (pref) { dir = dir.lerp(pref, uni).normalize(); } else dir.normalize();
                const L = branchLenMul * (2.6 * 0.45) * Math.pow(lenFall, levelIdx) * rr(r, 0.8, 1.2);
                const end = origin.clone().addScaledVector(dir, L);
                const t = Math.max(0.02, 0.07 * Math.pow(lenFall, levelIdx + 1));
                const seg = new THREE.Mesh(new THREE.BoxGeometry(t, t, L)); seg.userData.kind = 'branch';
                const q = new THREE.Quaternion(); q.setFromUnitVectors(new THREE.Vector3(0, 0, 1), dir);
                seg.quaternion.copy(q); seg.position.copy(origin.clone().addScaledVector(dir, L / 2));
                trunkGroup.add(seg); lastBranchSegments++;

                if (depthLeft <= 1) { addTerminal(end, dir); return; }
                // spawn children from this endpoint
                let n = Math.floor(rr(r, childMin, childMax + 1) * densityMul);
                if (PRESETS[treeType.value].branchPattern === 'whorl') { n = Math.max(3, Math.round(4 * densityMul)); }
                if (PRESETS[treeType.value].branchPattern === 'tiers') { n = Math.max(2, Math.round(3 * densityMul)); }
                n = Math.max(1, n);
                for (let k = 0; k < n; k++) {
                    // for whorls distribute yaw evenly
                    let dirChild = dir.clone();
                    if (PRESETS[treeType.value].branchPattern === 'whorl') {
                        const yawW = (k / n) * Math.PI * 2; dirChild.applyAxisAngle(new THREE.Vector3(0, 1, 0), yawW);
                    }
                    grow(end, dirChild, levelIdx + 1, depthLeft - 1);
                }
            }

            // Start recursive branching from last N trunk joints
            const jointsToUse = PRESETS[treeType.value].branchPattern === 'whorl' ? 5 : 3;
            const start = Math.max(1, pts.length - jointsToUse);
            for (let i = start; i < pts.length; i++) {
                const [a, b] = pts[i]; const dir = new THREE.Vector3().subVectors(b, a).normalize();
                // root fan of first-level branches from each joint
                let n0 = Math.max(1, Math.floor(rr(r, childMin, childMax + 1) * densityMul));
                if (PRESETS[treeType.value].branchPattern === 'whorl') { n0 = Math.max(3, Math.round(4 * densityMul)); }
                for (let m = 0; m < n0; m++) {
                    let d0 = dir.clone();
                    if (PRESETS[treeType.value].branchPattern === 'whorl') {
                        const yaw0 = (m / n0) * Math.PI * 2; d0.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw0);
                    }
                    grow(b, d0, i, depthBranches); // recursive depth
                }
            }

            applyRenderStyle();

            // --- keep camera EXACTLY the same (prevent tiny drift) ---
            const dampingWas = controls.enableDamping;
            const autoWas = (typeof controls.autoRotate === 'boolean') ? controls.autoRotate : false;
            const enabledWas = controls.enabled;
            const holdWas = holdSpin;

            holdSpin = 0;
            controls.enableDamping = false;
            controls.enabled = false;
            if (typeof controls.autoRotate === 'boolean') controls.autoRotate = false;

            // Restore camera transforms exactly
            camera.position.copy(camPos);
            controls.target.copy(camTarget);
            camera.updateProjectionMatrix();

            // Restore ike transform exactly (object stays where user left it)
            ike.position.copy(ikePos);
            ike.rotation.copy(ikeRot);
            ike.scale.copy(ikeScale);

            // Restore flags
            controls.enableDamping = dampingWas;
            controls.enabled = enabledWas;
            if (typeof controls.autoRotate === 'boolean') controls.autoRotate = autoWas;
            holdSpin = holdWas;
        }


        function applyVesselOnly() {
            makeVessel(vesselType.value, parseFloat(vesselDia.value), parseFloat(vesselDepth.value));
            updateSpinPivotFromVessel();
        }


        function savePNG() {
            const a = document.createElement('a'); a.download = `bonsai_${Date.now()}.png`; a.href = renderer.domElement.toDataURL('image/png'); a.click();
        }

        function tick() {
            const dt = clock.getDelta();
            applySpins(dt);          // << smooth spin is applied here
            controls.update();
            renderer.render(scene, camera);
            renderHUD();

            requestAnimationFrame(tick);
        }

        // Bindings
        const bindLive = (el, fn) => { el.addEventListener('input', fn); el.addEventListener('change', fn); };
        [treeType, levels, curvature, uniformity, spread, upBias, bDepth, bMin, bMax, bLen, density, leafSpread, leafType, plumage].forEach(el => bindLive(el, regenerate));
        [wireToggle, renderMode].forEach(el => bindLive(el, applyRenderStyle));
        [vesselType, vesselDia, vesselDepth, vesselColor].forEach(el => bindLive(el, applyVesselOnly));
        [bgColor, bgTex].forEach(el => bindLive(el, applyBackground));
        keyLightUI.addEventListener('input', () => { dir.intensity = parseFloat(keyLightUI.value); });
        hemiLightUI.addEventListener('input', () => { hemi.intensity = parseFloat(hemiLightUI.value); });
        exposureUI.addEventListener('input', () => { renderer.toneMappingExposure = parseFloat(exposureUI.value); });
        emissiveStrengthUI.addEventListener('input', applyRenderStyle);

        // Left/Right: smooth while held; also pause auto when you touch them
        function onHold(dir, isDown) {
            setAutoRotate(false);
            holdSpin = isDown ? dir : 0;
        }
        // Left
        rotLeft.addEventListener('mousedown', () => onHold(+1, true));
        rotLeft.addEventListener('mouseup', () => onHold(+1, false));
        rotLeft.addEventListener('touchstart', (e) => { e.preventDefault(); onHold(+1, true); }, { passive: false });
        rotLeft.addEventListener('touchend', () => { onHold(+1, false); }, { passive: true });
        // Right
        rotRight.addEventListener('mousedown', () => onHold(-1, true));
        rotRight.addEventListener('mouseup', () => onHold(-1, false));
        rotRight.addEventListener('touchstart', (e) => { e.preventDefault(); onHold(-1, true); }, { passive: false });
        rotRight.addEventListener('touchend', () => { onHold(-1, false); }, { passive: true });

        // Play/Pause + speed
        autoBtn.addEventListener('click', () => setAutoRotate(!autoOn));
        if (autoSpeedUI) autoSpeedUI.addEventListener('input', () => {/* no-op: read live in tick() */ });
        if (autoRotate) autoRotate.addEventListener('change', () => setAutoRotate(autoRotate.value === 'on'));

        if (debugToggle) {
            debugToggle.addEventListener('change', () => {
                // no-op; renderHUD() pulls the state each frame
            });
        }
        // handy hotkey: backtick toggles HUD
        window.addEventListener('keydown', (e) => {
            if (e.key === '`') {
                if (debugToggle) debugToggle.checked = !debugToggle.checked;
            }
        });

        frameBtn.addEventListener('click', () => {
            const box = new THREE.Box3().setFromObject(ike);
            const s = box.getSize(new THREE.Vector3());
            const c = controls.target.clone();

            // distance to fit the largest dimension
            const max = Math.max(s.x, s.y, s.z);
            const dist = max / (2 * Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5))) + 2;

            // view direction slightly elevated
            const dirV = new THREE.Vector3(1, 0.6, 1).normalize();
            camera.position.copy(c).addScaledVector(dirV, dist);
            camera.near = Math.max(0.01, dist * 0.02);
            camera.far = dist * 10;
            camera.updateProjectionMatrix();
            controls.update();
        });

        shotBtn.addEventListener('click', savePNG);
        newSeedBtn.addEventListener('click', () => { setSeed((Math.random() * 0xFFFFFFFF) >>> 0); regenerate(); });
        window.addEventListener('keydown', (e) => { if (e.code === 'Space') { e.preventDefault(); setSeed((Math.random() * 0xFFFFFFFF) >>> 0); regenerate(); } });

        // === Theme switching ===
        const THEMES = ['cyan', 'magenta', 'amber', 'lime'];
        const rootEl = document.documentElement;   // <html>
        const themeSelect = document.getElementById('themeSelect');

        function applyTheme(val) {
            // sanitize
            const t = THEMES.includes(val) ? val : 'cyan';
            // remove all, add one
            rootEl.classList.remove(...THEMES.map(x => `theme-${x}`));
            rootEl.classList.add(`theme-${t}`);
            // keep UI + storage in sync
            if (themeSelect) themeSelect.value = t;
            localStorage.setItem('bonsaiTheme', t);
        }

        // 1) Startup: apply saved (or default), ensuring we *remove* any previous class
        document.addEventListener('DOMContentLoaded', () => {
            applyTheme(localStorage.getItem('bonsaiTheme') || 'cyan');
        });

        // 2) Dropdown changes
        if (themeSelect) {
            themeSelect.addEventListener('change', (e) => applyTheme(e.target.value));
        }



        function initial() {
            applyBackground();
            setSeed((Math.random() * 0xFFFFFFFF) >>> 0);
            regenerate();
            if (!didInitialFrame) { frameBtn.click(); didInitialFrame = true; }
            if (autoSpeedUI) { controls.autoRotateSpeed = parseFloat(autoSpeedUI.value); }
            setAutoRotate(true);
            tick();
            renderHUD();

        }

        initial();

        // Tests (console)
        (function tests() {
            const seedBefore = currentSeed;
            const camPos0 = camera.position.clone(); const tgt0 = controls.target.clone();
            treeType.value = 'pine'; regenerate(); console.assert(currentSeed === seedBefore, 'Seed changed when switching type');
            console.assert(camera.position.distanceTo(camPos0) < 1e-6 && controls.target.distanceTo(tgt0) < 1e-6, 'Camera moved on parameter change');

            // Start low, then increase (monotonic)
            bDepth.value = '1'; bLen.value = '0.7'; regenerate(); const segLow = lastBranchSegments; const tLow = lastTerminalPieces;
            bDepth.value = '3'; bLen.value = '1.0'; regenerate(); const segMid = lastBranchSegments; const tMid = lastTerminalPieces;
            bDepth.value = '4'; bLen.value = '1.6'; regenerate(); const segHigh = lastBranchSegments; const tHigh = lastTerminalPieces;
            console.assert(segMid > segLow && segHigh >= segMid, 'Branch depth/length did not increase segment count');
            console.assert(tMid > tLow && tHigh >= tMid, 'More depth did not increase terminals');

            const beforeBox = new THREE.Box3().setFromObject(ike).getSize(new THREE.Vector3()).x;
            leafSpread.value = '2.0'; regenerate();
            const afterBox = new THREE.Box3().setFromObject(ike).getSize(new THREE.Vector3()).x;
            console.assert(afterBox > beforeBox, 'Leaf spread did not widen silhouette');

            const exp0 = renderer.toneMappingExposure;
            exposureUI.value = String(exp0 * 1.5); renderer.toneMappingExposure = parseFloat(exposureUI.value); renderer.render(scene, camera);
            console.assert(renderer.toneMappingExposure > exp0, 'Exposure slider not applied');

            // Plumage upward should raise bbox height vs random (allow some variance)
            plumage.value = 'upward'; regenerate(); const hUp = new THREE.Box3().setFromObject(ike).getSize(new THREE.Vector3()).y;
            plumage.value = 'random'; regenerate(); const hRand = new THREE.Box3().setFromObject(ike).getSize(new THREE.Vector3()).y;
            console.assert(hUp >= hRand * 0.9, 'Plumage upward bias not applied');

            // Emissive intensity wiring
            renderMode.value = 'emissive'; applyRenderStyle();
            const before = parseFloat(emissiveStrengthUI.value);
            emissiveStrengthUI.value = String(before + 0.5); applyRenderStyle();
            let found = false; treeGroup.traverse(o => { if (o.isMesh && o.material.emissiveIntensity !== undefined) { found = true; } });
            console.assert(found, 'Emissive mode did not apply emissive materials');

            // Auto-rotate default ON and pause on manual nudge
            console.assert(controls.autoRotate === true, 'Auto-rotate should be ON by default');
            rotLeft.click(); console.assert(controls.autoRotate === false, 'Manual rotate should pause auto-rotate');

            // Reset
            leafSpread.value = '1.0'; bDepth.value = '3'; bLen.value = '1.0'; treeType.value = 'maple'; renderMode.value = 'toon'; wireToggle.value = 'off'; plumage.value = 'radial'; regenerate();
            console.info('%cTest cases passed', 'color:#9f9');
        })();

    </script>
</body>

</html>
