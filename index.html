<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>POLYGON BONSAI / Ikebana Style</title>
    <style>
        /* =======================================================================
   GEOMETRIC BONSAI — Unified Design System (Techno Minimal)
   - Hue-driven accent themes
   - Light/Dark mode aware
   - Role-based component styling
   ======================================================================= */

        /* -----------------------------------------------------------------------------
   1) PRIMITIVES (mode-agnostic)
   ----------------------------------------------------------------------------- */
        :root {
            /* Typography & layout */
            --font-sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
            --font-mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;

            --panel-w: 380px;
            --r-1: 6px;
            --r-2: 8px;
            --r-3: 10px;
            --s-1: .35rem;
            --s-2: .6rem;
            --s-3: .7rem;
            --s-4: .75rem;
            --s-5: 1rem;

            /* Fallback neutrals (will be mapped by mode) */
            --surface-0-base: #0e1115;
            /* canvas */
            --surface-1-base: #0f141a;
            /* panel */
            --surface-2-base: #141a22;
            /* controls */

            /* Lines (base) */
            --c-line: rgba(255, 255, 255, .08);
            --c-line-strong: rgba(255, 255, 255, .12);

            /* Accent ramp (will be overridden by [data-accent]) */
            --accent-100: #e4fff8;
            --accent-200: #cafff1;
            --accent-300: #a7ffe9;
            --accent-400: #5df0c9;
            --accent-500: #38ffd8;
            --accent-600: #1ce3bf;
            --accent-700: #12b69b;
            --accent-800: #0b8d78;
            --accent-900: #0a6d5d;


            /* Interaction timing */
            --t-fast: 120ms;
            --t-med: 220ms;
            --t-slow: 360ms;
            --e-out: cubic-bezier(.17, .67, .2, 1);
            --e-in: cubic-bezier(.4, 0, .7, .2);

            /* On-accent text (set precisely by JS; fallback to near-black) */
            --text-on-accent: #0b0f12;

            /* Z */
            --z-stage: 1;
            --z-hud: 10;
        }

        /* -----------------------------------------------------------------------------
   2) ACCENT FAMILIES (hue groups) — set via #app[data-accent="..."]
   ----------------------------------------------------------------------------- */
        /* Cyan */
        #app[data-accent="cyan"] {
            --accent-100: #e4fff8;
            --accent-200: #cafff1;
            --accent-300: #a7ffe9;
            --accent-400: #5df0c9;
            --accent-500: #38ffd8;
            --accent-600: #1ce3bf;
            --accent-700: #12b69b;
            --accent-800: #0b8d78;
            --accent-900: #0a6d5d;
            --accent-on: #0b0f12;
        }

        /* Magenta */
        #app[data-accent="magenta"] {
            --accent-100: #fff1fb;
            --accent-200: #ffd5f5;
            --accent-300: #ffc4f6;
            --accent-400: #ff86f0;
            --accent-500: #ff5bea;
            --accent-600: #e544d1;
            --accent-700: #c22eb1;
            --accent-800: #97238a;
            --accent-900: #701a67;
            --accent-on: #0b0f12;
        }

        /* Amber */
        #app[data-accent="amber"] {
            --accent-100: #fff9e6;
            --accent-200: #fff1cc;
            --accent-300: #ffe8a1;
            --accent-400: #ffd46a;
            --accent-500: #ffcc4d;
            --accent-600: #f2b83a;
            --accent-700: #d19a25;
            --accent-800: #a9791a;
            --accent-900: #7f5914;
            --accent-on: #0b0f12;
        }

        /* Lime */
        #app[data-accent="lime"] {
            --accent-100: #f3ffe3;
            --accent-200: #e7ffc8;
            --accent-300: #e9ffc8;
            --accent-400: #cdfb89;
            --accent-500: #b7ff64;
            --accent-600: #9deb49;
            --accent-700: #79c52e;
            --accent-800: #5a9a23;
            --accent-900: #3f6f19;
            --accent-on: #0b0f12;
        }

        /* Black (Monochrome high-contrast) */
        #app[data-accent="black"] {
            --accent-100: #f5f5f5;
            --accent-200: #e0e0e0;
            --accent-300: #c2c2c2;
            --accent-400: #9e9e9e;
            --accent-500: #757575;
            --accent-600: #555555;
            --accent-700: #333333;
            --accent-800: #1f1f1f;
            --accent-900: #000000;
            --accent-on: #ffffff;
        }

        /* White (inverse monochrome) */
        #app[data-accent="white"] {
            --accent-100: #ffffff;
            --accent-200: #fafafa;
            --accent-300: #f5f5f5;
            --accent-400: #e0e0e0;
            --accent-500: #cccccc;
            --accent-600: #aaaaaa;
            --accent-700: #888888;
            --accent-800: #555555;
            --accent-900: #222222;
            --accent-on: #0b0f12;
        }

        /* -----------------------------------------------------------------------------
   3) MODE MAPS (dark/light) — surfaces, borders, text roles
   ----------------------------------------------------------------------------- */
        /* DARK */
        #app[data-mode="dark"] {
            /* Surfaces (subtle accent tint) */
            --surface-0: color-mix(in oklab, var(--surface-0-base) 96%, var(--accent-900));
            --surface-1: color-mix(in oklab, var(--surface-1-base) 96%, var(--accent-900));
            --surface-2: color-mix(in oklab, var(--surface-2-base) 96%, var(--accent-900));

            /* Borders */
            --outline: color-mix(in oklab, var(--accent-600) 14%, var(--surface-1));
            --outline-strong: color-mix(in oklab, var(--accent-600) 22%, var(--surface-1));

            /* Text by surface */
            --text-on-surface-0: color-mix(in oklab, var(--accent-100) 88%, transparent);
            --text-on-surface-1: color-mix(in oklab, var(--accent-100) 84%, transparent);
            --text-on-surface-2: color-mix(in oklab, var(--accent-100) 92%, transparent);

            /* Accent-tinted text choices (use light end for dark mode) */
            --text-accent-strong: var(--accent-300);
            --text-accent: var(--accent-200);
            --text-accent-muted: color-mix(in oklab, var(--accent-200) 70%, var(--text-on-surface-1));

            /* Role aliases used by UI */
            --text-strong: var(--text-on-surface-2);
            --text-heading: var(--text-accent-strong);
            --text-subtle: var(--text-accent);
            --text-dim: var(--text-accent-muted);

            /* HUD */
            --hud-border: 1px solid color-mix(in oklab, var(--accent-500) 35%, transparent);
            --hud-bg: linear-gradient(180deg,
                    color-mix(in oklab, var(--surface-1) 76%, transparent),
                    color-mix(in oklab, var(--surface-1) 56%, transparent));
            --hud-text: var(--accent-200);
            --hud-key: var(--accent-300);

            /* Controls */
            --ctl-bg: color-mix(in oklab, var(--surface-2) 92%, black 8%);
            --ctl-bg-hover: color-mix(in oklab, var(--surface-2) 88%, var(--accent-700) 12%);
            --ctl-bg-active: color-mix(in oklab, var(--surface-2) 84%, var(--accent-700) 16%);
            --ctl-bd: 1px solid color-mix(in oklab, var(--accent-600) 22%, var(--outline-strong));
            --ctl-bd-hover: 1px solid color-mix(in oklab, var(--accent-600) 42%, var(--outline-strong));
            --ctl-bd-active: 1px solid color-mix(in oklab, var(--accent-600) 55%, var(--outline-strong));

            /* Text inside controls */
            --text-on-control: var(--text-on-surface-2);

            /* Primary buttons */
            --btn-primary-bg: linear-gradient(180deg, var(--accent-600), var(--accent-700));
            --btn-primary-border: 1px solid var(--accent-700);
            --btn-primary-text: var(--accent-on);

            --glow-outer: 0 0 12px color-mix(in oklab, var(--accent-500) 16%, transparent);
            --glow-inner: inset 0 0 12px color-mix(in oklab, var(--accent-500) 8%, transparent);
            --focus-ring: 0 0 0 2px color-mix(in oklab, var(--accent-500) 28%, transparent);
            --blur: 3px;
        }

        /* LIGHT */
        #app[data-mode="light"] {
            /* Base neutrals */
            --surface-0-base: #f6f8fb;
            --surface-1-base: #eef2f7;
            --surface-2-base: #e7edf5;

            /* Surfaces (subtle accent tint) */
            --surface-0: color-mix(in oklab, var(--surface-0-base) 96%, var(--accent-200));
            --surface-1: color-mix(in oklab, var(--surface-1-base) 96%, var(--accent-200));
            --surface-2: color-mix(in oklab, var(--surface-2-base) 96%, var(--accent-200));

            /* Borders */
            --outline: color-mix(in oklab, var(--accent-700) 16%, #b7c4d6);
            --outline-strong: color-mix(in oklab, var(--accent-700) 26%, #a5b4c8);

            /* Text on each surface */
            --text-on-surface-0: color-mix(in oklab, var(--accent-900) 90%, transparent);
            --text-on-surface-1: color-mix(in oklab, var(--accent-900) 86%, transparent);
            --text-on-surface-2: color-mix(in oklab, var(--accent-900) 92%, transparent);

            /* Accent-tinted text choices (use dark end for light mode) */
            --text-accent-strong: var(--accent-800);
            --text-accent: var(--accent-700);
            --text-accent-muted: color-mix(in oklab, var(--accent-700) 65%, var(--text-on-surface-1));

            /* Role aliases used by UI */
            --text-strong: var(--text-on-surface-2);
            --text-heading: var(--text-accent-strong);
            --text-subtle: var(--text-accent);
            --text-dim: var(--text-accent-muted);

            /* HUD */
            --hud-border: 1px solid color-mix(in oklab, var(--accent-600) 40%, transparent);
            --hud-bg: linear-gradient(180deg,
                    color-mix(in oklab, var(--surface-1) 88%, transparent),
                    color-mix(in oklab, var(--surface-1) 70%, transparent));
            --hud-text: var(--accent-800);
            --hud-key: var(--accent-700);

            /* Controls */
            --ctl-bg: color-mix(in oklab, var(--surface-2) 96%, white 4%);
            --ctl-bg-hover: color-mix(in oklab, var(--surface-2) 92%, var(--accent-400) 12%);
            --ctl-bg-active: color-mix(in oklab, var(--surface-2) 88%, var(--accent-400) 18%);
            --ctl-bd: 1px solid color-mix(in oklab, var(--accent-600) 26%, var(--outline-strong));
            --ctl-bd-hover: 1px solid color-mix(in oklab, var(--accent-600) 42%, var(--outline-strong));
            --ctl-bd-active: 1px solid color-mix(in oklab, var(--accent-600) 55%, var(--outline-strong));

            /* Text inside controls */
            --text-on-control: var(--text-on-surface-2);

            /* Primary buttons */
            --btn-primary-bg: linear-gradient(180deg, var(--accent-600), var(--accent-700));
            --btn-primary-border: 1px solid var(--accent-700);
            --btn-primary-text: var(--accent-on);

            --glow-outer: 0 0 12px color-mix(in oklab, var(--accent-900) 16%, transparent);
            --glow-inner: inset 0 0 12px color-mix(in oklab, var(--accent-900) 8%, transparent);
            --focus-ring: 0 0 0 2px color-mix(in oklab, var(--accent-900) 28%, transparent);
            --blur: 3px;
        }

        /* -----------------------------------------------------------------------------
   4) GLOBAL BASE / LAYOUT
   ----------------------------------------------------------------------------- */
        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--surface-0);
            color: var(--text-on-surface-0);
            font-family: var(--font-mono);
        }

        #app {
            position: fixed;
            inset: 0;
            display: grid;
            grid-template-columns: var(--panel-w) 1fr;
            grid-template-rows: auto 1fr;
            grid-template-areas:
                "header header"
                "panel stage";
            background: var(--surface-0);
            color: var(--text-on-surface-0);
        }

        /* -----------------------------------------------------------------------------
   5) HEADER
   ----------------------------------------------------------------------------- */
        header {
            grid-area: header;
            display: flex;
            align-items: center;
            gap: var(--s-4);
            padding: .65rem var(--s-5);
            background: linear-gradient(180deg,
                    color-mix(in oklab, var(--surface-1) 96%, transparent),
                    transparent);
            border-bottom: 1px solid var(--outline);
        }

        header h1 {
            font-size: 1rem;
            letter-spacing: .06em;
            margin: 0;
            color: var(--hud-key);
            font-weight: 600;
        }

        /* Right-side header tools (theme selectors, etc.) */
        header .header-tools {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: .5rem;
        }

        /* -----------------------------------------------------------------------------
   6) PANEL (side)
   ----------------------------------------------------------------------------- */
        #panel {
            grid-area: panel;
            overflow: auto;
            background: var(--surface-1);
            box-shadow: inset -1px 0 0 var(--outline);
            padding: 16px;
            box-sizing: border-box;
        }

        /* Section */
        .section {
            margin-bottom: 14px;
            border: 1px solid var(--outline);
            border-radius: var(--r-3);
            background: var(--surface-1);
            box-shadow: var(--glow-outer), var(--glow-inner);
        }

        .section>h2 {
            margin: 0;
            font-size: .9rem;
            padding: .55rem var(--s-3);
            color: var(--hud-key);
            border-bottom: 1px dashed var(--outline);
            letter-spacing: .03em;
        }

        /* Form grid */
        .form {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px 10px;
            align-items: center;
            padding: var(--s-2) var(--s-3);
        }

        .full {
            grid-column: 1 / -1;
        }

        .row {
            display: flex;
            flex-wrap: wrap;
            gap: .4rem;
            align-items: center;
        }

        .form label,
        .section label,
        label {
            color: var(--accent-300) !important;
        }

        /* -----------------------------------------------------------------------------
   7) SHARED CONTROL BASE (inputs/buttons/selects)
   ----------------------------------------------------------------------------- */
        .control,
        select,
        input[type="text"],
        input[type="number"],
        input[type="color"],
        input[type="range"],
        .button,
        .btn {
            width: 100%;
            box-sizing: border-box;
            background: var(--surface-2);
            color: var(--text-on-surface-2);
            border: 1px solid var(--outline-strong);
            border-radius: var(--r-2);
            transition: background var(--t-med) var(--e-out),
                border-color var(--t-med) var(--e-out),
                box-shadow var(--t-med) var(--e-out),
                transform var(--t-fast) var(--e-out);
            box-shadow: 0 1px 0 rgba(255, 255, 255, .04), inset 0 1px 0 rgba(255, 255, 255, .03);
        }

        .control:hover,
        select:hover,
        input[type="text"]:hover,
        input[type="number"]:hover,
        input[type="color"]:hover,
        .button:hover,
        .btn:hover {
            border-color: color-mix(in oklab, var(--accent-600) 42%, var(--outline-strong));
        }

        .control:active,
        select:active,
        input[type="text"]:active,
        input[type="number"]:active,
        input[type="color"]:active,
        .button:active,
        .btn:active {
            transform: translateY(.5px);
        }

        .control:focus-visible,
        select:focus-visible,
        input[type="text"]:focus-visible,
        input[type="number"]:focus-visible,
        input[type="color"]:focus-visible,
        input[type="range"]:focus-visible,
        .button:focus-visible,
        .btn:focus-visible {
            outline: none;
            box-shadow: var(--focus-ring);
        }

        /* Select */
        select {
            padding: .45rem .6rem;
        }

        /* Text/number */
        input[type="text"],
        input[type="number"] {
            padding: .45rem .6rem;
        }

        /* Color */
        input[type="color"] {
            padding: .2rem;
        }

        /* Buttons */
        .btn,
        .button {
            padding: .55rem var(--s-3);
            font-weight: 700;
            cursor: pointer;
            user-select: none;
        }

        /* Button variants */
        .btn-primary {
            background: var(--accent-600);
            border: 1px solid color-mix(in oklab, var(--accent-700) 60%, var(--accent-500));
            color: var(--btn-primary-text);
        }

        .btn-primary:hover {
            background: var(--accent-500);
            color: var(--text-on-accent);
        }

        .btn-primary:active {
            background: var(--accent-700);
            color: var(--text-on-accent);
        }

        .btn-ghost {
            background: transparent;
            border: 1px dashed color-mix(in oklab, var(--accent-600) 45%, var(--outline));
            color: var(--hud-key);
        }

        .btn-ghost:hover {
            background: color-mix(in oklab, var(--accent-600) 12%, transparent);
        }

        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            display: grid;
            place-items: center;
        }

        /* -----------------------------------------------------------------------------
   8) RANGE SLIDER
   ----------------------------------------------------------------------------- */
        input[type="range"] {
            height: 28px;
            width: 100%;
            padding: 0;
            background: transparent;
            border: none;
            box-shadow: none !important;
            -webkit-appearance: none;
            appearance: none;
            /* prevent UA accent fill */
        }

        input[type="range"]::-webkit-slider-runnable-track {
            height: 6px;
            background: linear-gradient(90deg, var(--accent-700), var(--accent-500));
            border-radius: 999px;
            border: none;
            box-shadow: inset 0 0 0 1px color-mix(in oklab, var(--accent-600) 40%, var(--outline-strong));
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-200);
            border: 2px solid var(--accent-600);
            margin-top: -5px;
            /* align thumb to track */
            box-shadow: 0 0 8px color-mix(in oklab, var(--accent-500) 50%, transparent);
            transition: transform var(--t-fast) var(--e-out), box-shadow var(--t-med) var(--e-out);
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.06);
            box-shadow: 0 0 14px color-mix(in oklab, var(--accent-500) 70%, transparent);
        }

        /* ===== Firefox track/thumb/progress ===== */
        /* In FF, the "progress" (before-thumb) is a separate layer; give both same look to avoid double coloring */
        input[type="range"]::-moz-range-track,
        input[type="range"]::-moz-range-progress {
            height: 6px;
            border-radius: 999px;
            background: linear-gradient(90deg, var(--accent-700), var(--accent-500));
            border: 1px solid color-mix(in oklab, var(--accent-600) 40%, var(--c-line-strong));
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-200);
            border: 2px solid var(--accent-600);
            box-shadow: 0 0 8px color-mix(in oklab, var(--accent-500) 50%, transparent);
        }


        /* -----------------------------------------------------------------------------
   9) SWITCH / TOGGLE
   ----------------------------------------------------------------------------- */
        .switch {
            --sw-w: 42px;
            --sw-h: 24px;
            position: relative;
            display: inline-block;
            width: var(--sw-w);
            height: var(--sw-h);
            background: var(--surface-2);
            border: 1px solid var(--outline-strong);
            border-radius: 999px;
            cursor: pointer;
            transition: background var(--t-med) var(--e-out), border-color var(--t-med) var(--e-out);
        }

        .switch input {
            display: none;
        }

        .switch .knob {
            position: absolute;
            top: 2px;
            left: 2px;
            width: calc(var(--sw-h) - 4px);
            height: calc(var(--sw-h) - 4px);
            background: var(--accent-200);
            border-radius: 50%;
            box-shadow: 0 0 8px color-mix(in oklab, var(--accent-500) 50%, transparent);
            transition: transform var(--t-med) var(--e-out), box-shadow var(--t-med) var(--e-out);
        }

        .switch input:checked+.knob {
            transform: translateX(calc(var(--sw-w) - var(--sw-h)));
            background: var(--accent-100);
            box-shadow: 0 0 14px color-mix(in oklab, var(--accent-500) 70%, transparent);
        }

        /* -----------------------------------------------------------------------------
   10) SEGMENTED CONTROL
   ----------------------------------------------------------------------------- */
        .segmented {
            display: inline-grid;
            grid-auto-flow: column;
            gap: 6px;
            padding: 6px;
            border-radius: var(--r-3);
            background: color-mix(in oklab, var(--surface-2) 85%, var(--accent-900));
            border: 1px solid color-mix(in oklab, var(--accent-600) 25%, var(--outline-strong));
        }

        .segmented .seg {
            padding: .35rem .6rem;
            border-radius: var(--r-2);
            background: transparent;
            color: var(--hud-key);
            border: 1px dashed color-mix(in oklab, var(--accent-600) 35%, var(--outline));
            cursor: pointer;
            user-select: none;
            transition: background var(--t-med) var(--e-out), border-color var(--t-med) var(--e-out);
        }

        .segmented .seg[aria-pressed="true"],
        .segmented .seg.is-active {
            background: color-mix(in oklab, var(--accent-600) 40%, var(--surface-1) 60%);
            border: 1px solid color-mix(in oklab, var(--accent-600) 60%, var(--outline-strong));
            color: var(--text-on-accent);
        }

        /* -----------------------------------------------------------------------------
   11) STAGE
   ----------------------------------------------------------------------------- */
        #stageWrap {
            grid-area: stage;
            position: relative;
        }

        #bgOverlay {
            position: absolute;
            inset: 0;
            z-index: 0;
        }

        #stage {
            position: absolute;
            inset: 0;
            z-index: var(--z-stage);
        }

        /* -----------------------------------------------------------------------------
   12) FOOTER / TIP BAR
   ----------------------------------------------------------------------------- */
        footer {
            position: absolute;
            bottom: 12px;
            left: var(--s-5);
            right: var(--s-5);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--s-3);
            padding: .4rem .6rem;
            color: var(--text-subtle);
            font-size: .85rem;
            background: linear-gradient(180deg,
                    color-mix(in oklab, var(--surface-1) 65%, transparent),
                    color-mix(in oklab, var(--surface-1) 40%, transparent));
            border: 1px solid var(--outline);
            border-radius: var(--r-3);
            box-shadow: var(--glow-outer);
        }

        .kbd {
            background: var(--surface-1);
            border: 1px solid color-mix(in oklab, var(--accent-600) 30%, var(--outline-strong));
            color: var(--hud-key);
            padding: .15rem .35rem;
            border-radius: var(--r-1);
            font-size: .85em;
        }

        /* -----------------------------------------------------------------------------
   13) HUD (adaptive position — aligns to panel width)
   ----------------------------------------------------------------------------- */
        #hud {
            position: absolute;
            top: 82px;
            left: calc(var(--panel-w) + 16px);
            max-width: 360px;
            max-height: 60vh;
            overflow: auto;
            padding: 10px 12px;
            border: var(--hud-border);
            background: var(--hud-bg);
            box-shadow: var(--glow-outer), var(--glow-inner);
            border-radius: var(--r-2);
            font: 12px/1.35 var(--font-mono);
            color: var(--hud-text);
            letter-spacing: .2px;
            backdrop-filter: blur(var(--blur));
            display: none;
            /* toggle via JS */
            z-index: var(--z-hud);
        }

        #hud .hdr {
            color: var(--hud-key);
            text-transform: uppercase;
            font-weight: 700;
            margin: 8px 0 4px;
            border-bottom: 1px dashed color-mix(in oklab, var(--accent-500) 35%, transparent);
            padding-bottom: 2px;
        }

        #hud .k {
            color: var(--hud-key);
        }

        #hud .v {
            color: color-mix(in oklab, var(--text-on-surface-1) 92%, var(--accent-200) 8%);
        }

        #hud .warn {
            color: #ffde69;
        }

        #hud .err {
            color: #ff8a8a;
        }

        /* -----------------------------------------------------------------------------
   14) SCROLLBARS (global, accent-tinted)
   ----------------------------------------------------------------------------- */
        * {
            scrollbar-width: thin;
            scrollbar-color: color-mix(in oklab, var(--accent-700) 25%, var(--surface-2)) var(--surface-1);
        }

        *::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        *::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--accent-700), var(--accent-500));
            border-radius: var(--r-2);
            border: 2px solid var(--surface-1);
            box-shadow: var(--glow-inner);
        }

        /* -----------------------------------------------------------------------------
   15) ACCESSIBILITY & MOTION
   ----------------------------------------------------------------------------- */
        *:focus-visible {
            outline: none;
            box-shadow: var(--focus-ring);
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                transition: none !important;
                animation: none !important;
            }
        }
    </style>

    <!-- Import map for bare specifier "three" -->
    <script type="importmap">
  { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
  </script>
</head>

<body>
    <div id="app" data-mode="light" data-accent="cyan">
        <header>
            <h1>POLYGON BONSAI / Ikebana Style</h1>

            <div class="header-tools">
                <!-- Accent theme dropdown -->
                <label for="themeSelect" class="theme-label">Theme</label>
                <select id="themeSelect" class="theme-dropdown" aria-label="Accent theme">
                    <option value="cyan">Cyan</option>
                    <option value="magenta">Magenta</option>
                    <option value="amber">Amber</option>
                    <option value="lime">Lime</option>
                    <option value="black">Black</option>
                    <option value="white">White</option>
                </select>
                <!-- Mode segmented control -->
                <div id="modeControl" class="segmented" role="group" aria-label="Color scheme">
                    <button type="button" class="seg" data-mode="dark" aria-pressed="false">Dark</button>
                    <button type="button" class="seg" data-mode="light" aria-pressed="true">Light</button>
                </div>
            </div>
        </header>

        <aside id="panel">
            <div class="section">
                <h2>Scene</h2> <!-- Debug HUD toggle -->
                <div class="form">
                    <!-- Cyberpunk HUD overlay -->
                    <label>Display Debug</label>
                    <input id="debugToggle" type="checkbox">
                    <div id="hud" aria-hidden="true"></div>
                    <label>Background</label>
                    <input id="bgColor" type="color" value="#0e1115" />
                    <label>Texture</label>
                    <select id="bgTex">
                        <option value="solid">Solid</option>
                        <option value="grain">Grain</option>
                        <option value="gradient">Gradient</option>
                        <option value="paper">Paper</option>
                    </select>
                    <label>Key</label>
                    <input id="keyLight" type="range" min="0" max="5" step="0.01" value="0.55" />
                    <label>Ambient</label>
                    <input id="hemiLight" type="range" min="0" max="5" step="0.01" value="0.9" />
                    <label>Exposure</label>
                    <input id="exposure" type="range" min="0.5" max="2.5" step="0.01" value="1" />
                    <div class="full row">
                        <button id="frame" class="btn btn-primary">Frame</button>
                        <button id="shot" class="btn">📸 Screenshot</button>
                        <button id="newSeed" class="btn">New Seed</button>
                        <span>Seed: <span id="seedLabel" class="kbd">—</span></span>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>Species</h2>
                <div class="form">
                    <label>Type</label>
                    <select id="treeType">
                        <option value="magnolia">Magnolia (petals, arching)</option>
                        <option value="maple">Maple (broad, lobed)</option>
                        <option value="pine">Pine (upright, whorled)</option>
                        <option value="olive">Olive (compact, slabs)</option>
                        <option value="juniper">Juniper (windswept)</option>
                        <option value="ginkgo">Ginkgo (tiered fans)</option>
                    </select>
                    <label>Levels</label>
                    <input id="levels" type="range" min="3" max="10" step="1" value="6" />
                    <label>Curvature</label>
                    <input id="curvature" type="range" min="0" max="1" step="0.01" value="0.55" />
                    <label>Uniformity</label>
                    <input id="uniformity" type="range" min="0" max="1" step="0.01" value="0.6" />
                    <label>Spread</label>
                    <input id="spread" type="range" min="0.3" max="1.2" step="0.01" value="0.75" />
                    <label>Up-Bias</label>
                    <input id="upBias" type="range" min="0" max="1" step="0.01" value="0.3" />
                </div>
            </div>
            <div class="section">
                <h2>Leaves</h2>
                <div class="form">
                    <label>Leaf Type</label>
                    <select id="leafType">
                        <option value="diamond">Diamond</option>
                        <option value="needle">Needle</option>
                        <option value="slab">Slab</option>
                        <option value="sphere">Sphere</option>
                        <option value="triangle">Triangle</option>
                        <option value="cone">Cone</option>
                        <option value="teardrop">Teardrop</option>
                        <option value="half">Half‑circle</option>
                        <option value="crescent">Crescent</option>
                        <option value="petal">Petal (flower)</option>
                    </select>
                    <label>Plumage</label>
                    <select id="plumage">
                        <option value="random">Random</option>
                        <option value="upward">Upward</option>
                        <option value="radial">Radial</option>
                        <option value="wind-left">Wind →</option>
                        <option value="wind-right">Wind ←</option>
                    </select>
                    <label>Leaf Color</label>
                    <input id="leafColor" type="color" value="#2d6e52">
                    <label>Per-level Min</label>
                    <input id="bMin" type="range" min="1" max="6" step="1" value="2" />
                    <label>Per-level Max</label>
                    <input id="bMax" type="range" min="1" max="8" step="1" value="3" />
                    <label>Terminal Density</label>
                    <input id="density" type="range" min="0.3" max="3" step="0.01" value="1" />
                    <label>Leaf Spread</label>
                    <input id="leafSpread" type="range" min="0.3" max="2.5" step="0.01" value="1" />

                </div>
            </div>

            <div class="section">
                <h2>Branchlets</h2>
                <div class="form">
                    <label>Branch Color</label>
                    <input id="branchColor" type="color" value="#3b2d44">

                    <label>Depth</label>
                    <input id="bDepth" type="range" min="1" max="4" step="1" value="3" />

                    <label>Branch Length</label>
                    <input id="bLen" type="range" min="0.5" max="1.8" step="0.01" value="1" />
                </div>
            </div>

            <div class="section">
                <h2>Vessel</h2>
                <div class="form">
                    <label>Color</label>
                    <input id="vesselColor" type="color" value="#a5b2bd" />
                    <label>Type</label>
                    <select id="vesselType">
                        <option value="glass-cylinder">Glass Cylinder</option>
                        <option value="shallow-bowl">Shallow Bowl</option>
                        <option value="faceted">Faceted Prism</option>
                        <option value="stone-disc">Stone Disc</option>
                    </select>
                    <label>Diameter</label>
                    <input id="vesselDia" type="range" min="0.8" max="2.4" step="0.01" value="1.2" />
                    <label>Depth</label>
                    <input id="vesselDepth" type="range" min="0.2" max="2.5" step="0.01" value="1.6" />
                </div>
            </div>

            <div class="section">
                <h2>Render & Appearance</h2>
                <div class="form">
                    <label>Auto rotate</label>
                    <select id="autoRotate">
                        <option value="off">Off</option>
                        <option value="on" selected>On</option>
                    </select>
                    <button id="autoBtn" class="btn">⏸ Pause</button>
                    <input id="autoSpeed" type="range" min="-4" max="4" step="0.01" value="0.8" />
                    <button id="rotLeft" class="btn">⟲ Left</button>
                    <button id="rotRight" class="btn">⟳ Right</button>
                    <label>Wireframe</label>
                    <select id="wireToggle">
                        <option value="off">Off</option>
                        <option value="on">On</option>
                    </select>
                    <label>Render Mode</label>
                    <select id="renderMode">
                        <option value="toon">Toon</option>
                        <option value="sketchy">Sketchy</option>
                        <option value="metallic">Metallic</option>
                        <option value="holographic">Holographic</option>
                        <option value="emissive">Emissive</option>
                    </select>
                    <label>Emissive Color</label>
                    <input id="emissiveColor" type="color" value="#94e3ff">
                    <label>Emissive Strength</label>
                    <input id="emissiveStrength" type="range" min="0" max="1" step="0.01" value="0.5" />
                </div>

            </div>
        </aside>

        <div id="stageWrap">
            <div id="bgOverlay"></div>
            <div id="stage"></div>
            <footer>
                <div>Tip: drag to orbit · wheel/pinch to zoom</div>
                <div>Press <span class="kbd">Frame</span> to refit</div>
            </footer>
        </div>

    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

        // --- UI refs ---
        const $ = (id) => document.getElementById(id);
        const stage = $('stage');
        const bgOverlay = $('bgOverlay');
        const seedLabel = $('seedLabel');
        const treeType = $('treeType');
        const levels = $('levels');
        const curvature = $('curvature');
        const uniformity = $('uniformity');
        const spread = $('spread');
        const upBias = $('upBias');
        const bDepth = $('bDepth');
        const bMin = $('bMin');
        const bMax = $('bMax');
        const bLen = $('bLen');
        const density = $('density');
        const leafSpread = $('leafSpread');
        const leafType = $('leafType');
        const plumage = $('plumage');
        const vesselType = $('vesselType');
        const vesselDia = $('vesselDia');
        const vesselDepth = $('vesselDepth');
        const vesselColor = $('vesselColor');
        const applyVessel = $('applyVessel');
        const bgColor = $('bgColor');
        const bgTex = $('bgTex');
        const keyLightUI = $('keyLight');
        const hemiLightUI = $('hemiLight');
        const exposureUI = $('exposure');
        const frameBtn = $('frame');
        const shotBtn = $('shot');
        const newSeedBtn = $('newSeed');
        const wireToggle = $('wireToggle');
        const renderMode = $('renderMode');
        const emissiveStrengthUI = document.getElementById('emissiveStrength');
        const autoBtn = document.getElementById('autoBtn');
        const autoRotate = $('autoRotate');
        const autoSpeedUI = $('autoSpeed');
        const branchColorUI = $('branchColor');
        const leafColorUI = $('leafColor');
        const emissiveColorUI = $('emissiveColor');
        [branchColorUI, leafColorUI, emissiveColorUI].forEach(el => el && el.addEventListener('input', applyRenderStyle));

        const MAX_GLOBAL_LEAVES = 1000;   // safety cap
        let globalLeafCount = 0;

        let spinPivotY = 0;    // world Y of vessel base

        let frameNo = 0;
        let fpsEMA = 0;          // exponential moving avg
        const FPS_ALPHA = 0.12;  // smoothing factor

        const rotLeft = $('rotLeft');
        const rotRight = $('rotRight');

        // --- Scene ---
        const scene = new THREE.Scene();

        // Debug target gizmo (shows camera focus)
        const gizmo = new THREE.Group();
        const sphere = new THREE.Mesh(
            new THREE.SphereGeometry(0.05, 12, 12),
            new THREE.MeshBasicMaterial({ color: 0xffffff })
        );
        const axes = new THREE.AxesHelper(0.4);
        gizmo.add(axes, sphere);
        scene.add(gizmo);

        const camera = new THREE.PerspectiveCamera(38, 1, 0.1, 200);
        camera.position.set(6, 4.2, 11);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
        renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
        renderer.outputColorSpace = THREE.SRGBColorSpace;     // r160 uses outputColorSpace
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = parseFloat(exposureUI.value);
        stage.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.08;
        controls.minDistance = 4; controls.maxDistance = 30;
        controls.maxPolarAngle = Math.PI * 0.95; controls.target.set(0, 0, 0);
        controls.autoRotate = false; // disable internal camera spin

        const hemi = new THREE.HemisphereLight(0xf4efe8, 0x0b0f12, parseFloat(hemiLightUI.value));
        const dir = new THREE.DirectionalLight(0xffffff, parseFloat(keyLightUI.value)); dir.position.set(3, 5, 4);
        scene.add(hemi, dir);

        const root = new THREE.Group(); scene.add(root);
        let ike = new THREE.Group(); root.add(ike);
        let vesselGroup = null, treeGroup = null, sketchOverlay = null;
        let didInitialFrame = false;

        // --- Smooth autorotation & manual spin ---
        const clock = new THREE.Clock();
        let autoOn = true;              // default ON
        let holdSpin = 0;               // -1 = right, +1 = left while pressed
        const AUTO_BASE = 0.8;          // base radians/sec scale for speed slider

        const debugToggle = $('debugToggle');
        const hud = $('hud');

        // handy formatters
        const d = (n) => Number.isFinite(n) ? n.toFixed(3) : 'NaN';
        const deg = (r) => d(THREE.MathUtils.radToDeg(r));
        const v3 = (v) => `${d(v.x)}, ${d(v.y)}, ${d(v.z)}`;
        const eulerDeg = (e) => `${deg(e.x)}, ${deg(e.y)}, ${deg(e.z)}`;

        function renderHUD() {
            if (!debugToggle || !hud) return;
            const on = !!debugToggle.checked;
            hud.style.display = on ? 'block' : 'none';
            if (!on) return;

            // gather data
            const cam = camera;
            const tgt = controls.target;
            const ikeRot = ike.rotation;
            const ikePos = ike.position;
            const ikeScale = ike.scale;

            const ems = emissiveStrengthUI ? parseFloat(emissiveStrengthUI.value) : 0;
            const w = wireToggle ? (wireToggle.value === 'on') : false;

            const ri = renderer.info;

            // counts come from your generators:
            // lastBranchSegments, lastTerminalPieces, globalLeafCount
            // seed from currentSeed

            // vessel values
            const vType = vesselType ? vesselType.value : '';
            const vDia = vesselDia ? parseFloat(vesselDia.value) : 0;
            const vDep = vesselDepth ? parseFloat(vesselDepth.value) : 0;

            // tree settings
            const tSet = {
                type: treeType.value, levels: levels.value,
                bDepth: bDepth.value, bMin: bMin.value, bMax: bMax.value, bLen: bLen.value,
                curvature: curvature.value, uniformity: uniformity.value, upBias: upBias.value, spread: spread.value,
                density: density.value, leafSpread: leafSpread.value, leafType: leafType.value, plumage: plumage.value
            };

            const lines = [];
            lines.push(`<div class="hdr">runtime</div>`);
            lines.push(`<div><span class="k">frame</span> <span class="v">${frameNo}</span>  <span class="k">fps~</span> <span class="v">${fpsEMA.toFixed(1)}</span></div>`);
            lines.push(`<div><span class="k">auto</span> <span class="v">${autoOn ? 'on' : 'off'}</span>  <span class="k">speed</span> <span class="v">${autoSpeedUI ? autoSpeedUI.value : '—'}</span></div>`);
            lines.push(`<div class="hdr">camera</div>`);
            lines.push(`<div><span class="k">pos</span> <span class="v">${v3(cam.position)}</span></div>`);
            lines.push(`<div><span class="k">rot(deg)</span> <span class="v">${eulerDeg(cam.rotation)}</span></div>`);
            lines.push(`<div><span class="k">target</span> <span class="v">${v3(tgt)}</span></div>`);
            lines.push(`<div class="hdr">object (ike)</div>`);
            lines.push(`<div><span class="k">pos</span> <span class="v">${v3(ikePos)}</span></div>`);
            lines.push(`<div><span class="k">rot(deg)</span> <span class="v">${eulerDeg(ikeRot)}</span></div>`);
            lines.push(`<div><span class="k">scale</span> <span class="v">${v3(ikeScale)}</span></div>`);
            lines.push(`<div><span class="k">seed</span> <span class="v">${currentSeed}</span></div>`);
            lines.push(`<div class="hdr">vessel</div>`);
            lines.push(`<div><span class="k">type</span> <span class="v">${vType}</span></div>`);
            lines.push(`<div><span class="k">dia</span> <span class="v">${d(vDia)}</span>  <span class="k">depth</span> <span class="v">${d(vDep)}</span></div>`);
            lines.push(`<div class="hdr">tree</div>`);
            lines.push(`<div><span class="k">type</span> <span class="v">${tSet.type}</span>  <span class="k">levels</span> <span class="v">${tSet.levels}</span></div>`);
            lines.push(`<div><span class="k">branch</span> <span class="v">depth ${tSet.bDepth}, min ${tSet.bMin}, max ${tSet.bMax}, len ${tSet.bLen}</span></div>`);
            lines.push(`<div><span class="k">shape</span> <span class="v">curv ${tSet.curvature}, uni ${tSet.uniformity}, upBias ${tSet.upBias}, spread ${tSet.spread}</span></div>`);
            lines.push(`<div><span class="k">leaves</span> <span class="v">${tSet.leafType}, spread ${tSet.leafSpread}, density ${tSet.density}, plumage ${tSet.plumage}</span></div>`);
            lines.push(`<div class="hdr">render</div>`);
            lines.push(`<div><span class="k">mode</span> <span class="v">${renderMode.value}</span>  <span class="k">wire</span> <span class="v">${w ? 'on' : 'off'}</span>  <span class="k">emiss</span> <span class="v">${ems}</span></div>`);
            lines.push(`<div class="hdr">counts</div>`);
            lines.push(`<div><span class="k">segments</span> <span class="v">${lastBranchSegments}</span>  <span class="k">terminals</span> <span class="v">${lastTerminalPieces}</span>  <span class="k">globalLeaves</span> <span class="v">${globalLeafCount}</span></div>`);

            lines.push(`<div class="hdr">gpu</div>`);
            lines.push(`<div><span class="k">calls</span> <span class="v">${ri.render.calls}</span>  <span class="k">tri</span> <span class="v">${ri.render.triangles}</span>  <span class="k">points</span> <span class="v">${ri.render.points}</span></div>`);


            hud.innerHTML = lines.join('');
        }

        function spinBy(radPerSec, dt) {
            if (!radPerSec || !dt) return;
            // rotate the whole arrangement around Y at spin pivot
            // keep rotation “in place” visually relative to pivot Y
            ike.rotation.y += radPerSec * dt;
        }

        function applySpins(dt) {
            const uiSpeed = (autoSpeedUI) ? parseFloat(autoSpeedUI.value) : 0.8;
            if (autoOn && uiSpeed !== 0) spinBy(uiSpeed * AUTO_BASE, dt);
            if (holdSpin !== 0) spinBy(holdSpin * 1.2, dt);
        }

        // convenience from UI
        function setAutoRotate(on) {
            autoOn = !!on;                            // our smooth rot flag
            if (autoRotate) autoRotate.value = autoOn ? 'on' : 'off';
            if (autoBtn) autoBtn.textContent = autoOn ? '⏸ Pause' : '▶ Play';
        }

        function onResize() {
            const rect = stage.getBoundingClientRect();
            const w = Math.max(1, rect.width);
            const h = Math.max(1, rect.height);
            renderer.setSize(w, h, false);
            camera.aspect = w / h; camera.updateProjectionMatrix();
        }
        window.addEventListener('resize', onResize); onResize();

        // RNG
        function mulberry32(a) { return function () { let t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; }; }
        const seeded = (s) => mulberry32(s >>> 0);
        const rr = (r, min, max) => min + r() * (max - min);

        // Materials (DoubleSide to avoid backface holes)
        const DS = THREE.DoubleSide;
        const mats = {
            branch: new THREE.MeshToonMaterial({ color: 0x3b2d44, side: DS }),
            leaf: new THREE.MeshToonMaterial({ color: 0x2d6e52, transparent: true, opacity: 0.95, side: DS }),
            petal: new THREE.MeshToonMaterial({ color: 0xf3e7da, transparent: true, opacity: 0.98, side: DS }),
            accent: new THREE.MeshToonMaterial({ color: 0xd6b36a, transparent: true, opacity: 0.95, side: DS }),
            glass: new THREE.MeshPhysicalMaterial({ color: 0xa5b2bd, metalness: 0, roughness: 0.2, transmission: 0.9, ior: 1.2, thickness: 0.8, transparent: true, opacity: 0.85, side: DS }),
            water: new THREE.MeshPhysicalMaterial({ color: 0x5b7a86, metalness: 0, roughness: 0.4, transmission: 0.9, ior: 1.33, thickness: 0.2, transparent: true, opacity: 0.6, side: DS }),
            stone: new THREE.MeshStandardMaterial({ color: 0x545a5f, roughness: 0.9, metalness: 0.0, side: DS })
        };

        // Species presets
        const PRESETS = {
            magnolia: { spread: 0.6, upBias: 0.2, lenFalloff: 0.72, leaves: 'petal', trunk: 'arch', colors: { branch: 0x3b2d44, leaf: 0xf3e7da } },
            maple: { spread: 0.9, upBias: 0.15, lenFalloff: 0.70, leaves: 'diamond', trunk: 'splay', colors: { branch: 0x3b2d44, leaf: 0xd44a2f } },
            pine: { spread: 0.5, upBias: 0.6, lenFalloff: 0.76, leaves: 'needle', trunk: 'upright', branchPattern: 'whorl', colors: { branch: 0x2a3a2c, leaf: 0x1d4228 } },
            olive: { spread: 0.65, upBias: 0.4, lenFalloff: 0.74, leaves: 'slab', trunk: 'compact', colors: { branch: 0x403e3a, leaf: 0x6e7b64 } },
            juniper: { spread: 0.55, upBias: 0.45, lenFalloff: 0.75, leaves: 'teardrop', trunk: 'windswept', colors: { branch: 0x2e3a3f, leaf: 0x547b7c } },
            ginkgo: { spread: 0.8, upBias: 0.25, lenFalloff: 0.71, leaves: 'half', trunk: 'tiered', branchPattern: 'tiers', colors: { branch: 0x3b2d44, leaf: 0xe8b736 } }
        };

        let currentSeed = (Math.random() * 0xFFFFFFFF) >>> 0;
        let lastTerminalPieces = 0, lastBranchSegments = 0;

        function setSeed(seed) { currentSeed = seed >>> 0; seedLabel.textContent = String(currentSeed); }

        // Background textures
        function applyBackground() {
            const color = bgColor.value;
            bgOverlay.style.backgroundImage = '';
            if (bgTex.value === 'solid') {
                bgOverlay.style.background = color;
            } else if (bgTex.value === 'grain') {
                bgOverlay.style.background = `${color}`;
                bgOverlay.style.backgroundImage = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><filter id="n"><feTurbulence baseFrequency="0.8" type="fractalNoise" numOctaves="2"/><feColorMatrix type="saturate" values="0"/></filter><rect width="100" height="100" filter="url(%23n)" opacity="0.15"/></svg>')`;
                bgOverlay.style.backgroundBlendMode = 'overlay';
            } else if (bgTex.value === 'gradient') {
                bgOverlay.style.background = `radial-gradient(1000px 800px at 70% 25%, ${color}, #0a0e12)`;
            } else if (bgTex.value === 'paper') {
                bgOverlay.style.background = color;
                bgOverlay.style.backgroundImage = `linear-gradient(rgba(255,255,255,.03) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,.02) 1px, transparent 1px)`;
                bgOverlay.style.backgroundSize = '6px 6px, 6px 6px';
            }
        }

        function makeVessel(type, dia = 1.2, depth = 1.6) {
            if (vesselGroup) { ike.remove(vesselGroup); vesselGroup.traverse(o => { if (o.geometry) o.geometry.dispose(); }); }
            const g = new THREE.Group(); g.position.y = -1.6; vesselGroup = g; ike.add(g);
            const tint = new THREE.Color(vesselColor.value);
            mats.glass.color.copy(tint); mats.stone.color.copy(tint);
            if (type === 'glass-cylinder') {
                const outer = new THREE.Mesh(new THREE.CylinderGeometry(dia * 0.9, dia * 0.9, depth, 36, 1, true), mats.glass);
                const inner = new THREE.Mesh(new THREE.CylinderGeometry(dia * 0.82, dia * 0.82, depth * 0.92, 36, 1, true), mats.glass);
                const water = new THREE.Mesh(new THREE.CylinderGeometry(dia * 0.8, dia * 0.8, Math.max(0.2, depth * 0.45), 36), mats.water); water.position.y = -depth * 0.25;
                g.add(outer, inner, water);
            } else if (type === 'shallow-bowl') {
                const bowl = new THREE.Mesh(new THREE.CylinderGeometry(dia * 1.3, dia * 1.5, Math.max(0.25, depth * 0.35), 24, 1, true), mats.glass);
                bowl.position.y = -Math.max(0.05, depth * 0.1); g.add(bowl);
                const pool = new THREE.Mesh(new THREE.CylinderGeometry(dia * 1.2, dia * 1.2, Math.max(0.1, depth * 0.12), 24), mats.water); pool.position.y = -Math.max(0.08, depth * 0.18); g.add(pool);
            } else if (type === 'faceted') {
                const prism = new THREE.Mesh(new THREE.DodecahedronGeometry(Math.max(0.6, dia * 0.7), 0), mats.glass); prism.position.y = 0.1; g.add(prism);
            } else if (type === 'stone-disc') {
                const disc = new THREE.Mesh(new THREE.CylinderGeometry(dia * 1.4, dia * 1.4, Math.max(0.2, depth * 0.16), 36), mats.stone); disc.position.y = -depth * 0.6; g.add(disc);
            }
            return g;
        }

        function updateSpinPivotFromVessel() {
            if (!vesselGroup) return;
            const box = new THREE.Box3().setFromObject(vesselGroup);
            spinPivotY = box.min.y; // used for any future pivot math if needed
        }

        function orbitTargetToVesselBase() {
            if (!vesselGroup) return;
            const box = new THREE.Box3().setFromObject(vesselGroup);
            const baseY = box.min.y;
            controls.target.set(0, baseY, 0);
        }

        // Render styles (tree only)
        function applyRenderStyle() {
            const mode = renderMode.value;
            const wire = wireToggle.value === 'on';
            const branchColor = new THREE.Color(branchColorUI ? branchColorUI.value : mats.branch.color);
            const leafColor = new THREE.Color(leafColorUI ? leafColorUI.value : mats.leaf.color);
            const petalColor = mats.petal.color.clone();
            const emissiveCol = new THREE.Color(emissiveColorUI ? emissiveColorUI.value : leafColor);

            const setMat = (mesh, kind) => {
                let mat;
                if (mode === 'metallic') {
                    mat = new THREE.MeshStandardMaterial({
                        color: kind === 'branch' ? branchColor : (kind === 'petal' ? petalColor : leafColor),
                        metalness: 0.85, roughness: 0.25, wireframe: wire, side: DS
                    });
                }
                else if (mode === 'holographic') {
                    const base = new THREE.MeshPhysicalMaterial({
                        color: kind === 'branch' ? branchColor : (kind === 'petal' ? petalColor : leafColor),
                        metalness: 0.2, roughness: 0.1, transmission: 0.4,
                        transparent: true, opacity: 0.9, wireframe: wire, side: DS
                    });
                    base.onBeforeCompile = (shader) => {
                        shader.fragmentShader = shader.fragmentShader.replace('#include <output_fragment>', `
                        float fres = pow(1.0 - dot(normalize(vViewPosition), normalize(normal)), 2.0);
                        vec3 holo = mix(gl_FragColor.rgb, vec3(0.6,0.8,1.0), fres*0.9);
                        gl_FragColor = vec4(holo, gl_FragColor.a);
                    `);
                    };
                    mat = base;
                }
                else if (mode === 'emissive') {
                    mat = new THREE.MeshStandardMaterial({
                        color: (kind === 'branch' ? branchColor : (kind === 'petal' ? petalColor : leafColor)),
                        emissive: (kind === 'branch' ? branchColor : (kind === 'petal' ? petalColor : emissiveCol)),
                        emissiveIntensity: parseFloat(emissiveStrengthUI.value),
                        metalness: 0.0, roughness: 0.6, wireframe: wire, side: DS
                    });
                }
                else { // toon default
                    mat = (kind === 'petal') ? mats.petal.clone()
                        : (kind === 'branch' ? mats.branch.clone() : mats.leaf.clone());
                    mat.wireframe = wire; mat.side = DS;
                }
                mesh.material = mat;
            };


            if (treeGroup) {
                treeGroup.traverse(o => { if (o.isMesh) { const kind = o.userData.kind || 'branch'; setMat(o, kind); } });
            }

            if (sketchOverlay) { ike.remove(sketchOverlay); sketchOverlay.traverse(o => { if (o.geometry) o.geometry.dispose(); }); sketchOverlay = null; }
            if (mode === 'sketchy') {
                sketchOverlay = new THREE.Group();
                treeGroup.traverse(o => {
                    if (o.isMesh && o.geometry) {
                        const e = new THREE.EdgesGeometry(o.geometry, 15);
                        const lines = new THREE.LineSegments(e, new THREE.LineBasicMaterial({ color: 0x0b0b0b, transparent: true, opacity: 0.6 }));
                        lines.position.copy(o.position); lines.rotation.copy(o.rotation); lines.scale.copy(o.scale); lines.quaternion.copy(o.quaternion);
                        lines.userData.kind = 'sketch';
                        o.add(lines); sketchOverlay.add(lines);
                    }
                });
            }
        }

        function leafGeometry(kind) {
            switch (kind) {
                case 'sphere': return new THREE.IcosahedronGeometry(0.18, 0);
                case 'triangle': return new THREE.ConeGeometry(0.22, 0.32, 3);
                case 'cone': return new THREE.ConeGeometry(0.16, 0.5, 10);
                case 'diamond': return new THREE.OctahedronGeometry(0.18, 0);
                case 'slab': return new THREE.BoxGeometry(0.24, 0.08, 0.24);
                case 'needle': return new THREE.CylinderGeometry(0.02, 0.02, 0.7, 8);
                case 'half': { const pts = []; for (let i = 0; i <= 10; i++) { const a = (i / 10) * Math.PI; pts.push(new THREE.Vector2(Math.sin(a) * 0.22, Math.cos(a) * 0.22)); } return new THREE.LatheGeometry(pts, 16, 0, Math.PI); }
                case 'crescent': return new THREE.TorusGeometry(0.25, 0.06, 10, 24, Math.PI * 1.2);
                case 'teardrop': { const g = new THREE.Group(); g.add(new THREE.Mesh(new THREE.ConeGeometry(0.12, 0.5, 10))); const cap = new THREE.Mesh(new THREE.SphereGeometry(0.14, 12, 12)); cap.position.y = 0.24; g.add(cap); return g; }
                case 'petal': default: return new THREE.BoxGeometry(0.12, 0.8, 0.02);
            }
        }

        function regenerate() {
            // Snapshot camera + object transforms (to restore exactly)
            const camPos = camera.position.clone();
            const camTarget = controls.target.clone();

            // Preserve ike transform so object rotation never resets
            const ikePos = ike.position.clone();
            const ikeRot = ike.rotation.clone();
            const ikeScale = ike.scale.clone();

            // Clear children instead of replacing `ike`
            if (treeGroup) {
                ike.remove(treeGroup);
                treeGroup.traverse(o => { if (o.geometry) o.geometry.dispose(); });
                treeGroup = null;
            }
            if (vesselGroup) {
                ike.remove(vesselGroup);
                vesselGroup.traverse(o => { if (o.geometry) o.geometry.dispose(); });
                vesselGroup = null;
            }

            // Rebuild vessel + tree as children of the *same* `ike`
            makeVessel(vesselType.value, parseFloat(vesselDia.value), parseFloat(vesselDepth.value));

            // NOTE: do NOT re-center the camera target here.
            // Only recompute spin pivot, leave camera/target untouched.
            updateSpinPivotFromVessel();

            treeGroup = new THREE.Group();
            ike.add(treeGroup);

            const preset = PRESETS[treeType.value];
            mats.branch.color.set(preset.colors.branch);
            mats.leaf.color.set(preset.colors.leaf);

            const depth = parseInt(levels.value, 10);
            const sp = parseFloat(spread.value) || preset.spread;
            const up = parseFloat(upBias.value) || preset.upBias;
            const lenFall = preset.lenFalloff;
            const leavesKind = leafType.value || preset.leaves;
            const curv = parseFloat(curvature.value);
            const uni = parseFloat(uniformity.value);
            const childMin = parseInt(bMin.value, 10);
            const childMax = parseInt(bMax.value, 10);
            const depthBranches = parseInt(bDepth.value, 10);
            const branchLenMul = parseFloat(bLen.value);
            const densityMul = parseFloat(density.value);
            const leafSpreadMul = parseFloat(leafSpread.value);

            globalLeafCount = 0; // <-- reset once per generation HERE

            const r = seeded(currentSeed);

            // Trunk
            const trunkGroup = new THREE.Group(); treeGroup.add(trunkGroup);
            lastBranchSegments = 0;
            function addSegment(a, b, thickness) {
                const dir = new THREE.Vector3().subVectors(b, a); const len = dir.length(); dir.normalize();
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(thickness, thickness, len));
                mesh.userData.kind = 'branch';
                const quat = new THREE.Quaternion(); quat.setFromUnitVectors(new THREE.Vector3(0, 0, 1), dir);
                mesh.quaternion.copy(quat); mesh.position.copy(a.clone().addScaledVector(dir, len / 2));
                trunkGroup.add(mesh); lastBranchSegments++;
            }

            const pts = []; let p = new THREE.Vector3(rr(r, -0.05, 0.05), -0.9, rr(r, -0.05, 0.05));
            const upVec = new THREE.Vector3(0, 1, 0);
            let dir0 = new THREE.Vector3(rr(r, -0.1, 0.1), 1, rr(r, -0.1, 0.1)).normalize();
            let len = 2.6;
            const bendDir = (preset.trunk === 'windswept') ? new THREE.Vector3(1, 0, 0) : new THREE.Vector3(rr(r, -1, 1), 0, rr(r, -1, 1));
            bendDir.normalize().multiplyScalar(0.6 * curv);

            for (let i = 0; i < depth; i++) {
                let yawBias = bendDir.x * 0.35 + (1 - uni) * rr(r, -0.3, 0.3);
                let pitchBias = (preset.trunk === 'upright' ? 0.08 : 0.15) * curv + (1 - uni) * rr(r, -0.2, 0.2) + up * 0.05;
                if (preset.trunk === 'tiered' && i % 2 === 0) { yawBias *= 0.35; pitchBias *= 0.2; }
                if (preset.trunk === 'compact') { yawBias *= 0.5; pitchBias *= 0.5; }
                if (preset.trunk === 'splay') { yawBias += rr(r, -0.15, 0.15); }
                dir0 = dir0.clone().applyAxisAngle(upVec, yawBias).applyAxisAngle(new THREE.Vector3(1, 0, 0), pitchBias).normalize();
                const np = p.clone().addScaledVector(dir0, len);
                np.add(new THREE.Vector3(rr(r, -0.10, 0.10), rr(r, -0.05, 0.05), rr(r, -0.10, 0.10)).multiplyScalar(curv * 0.35));
                pts.push([p.clone(), np.clone(), Math.max(0.035, 0.10 * Math.pow(lenFall, i))]);
                p = np; len *= lenFall * rr(r, 0.95, 1.05);
            }
            pts.forEach(([a, b, t]) => addSegment(a, b, t));

            // Direction preferences
            function preferredDir(baseDir) {
                const mode = plumage.value;
                if (mode === 'upward') return new THREE.Vector3(0, 1, 0);
                if (mode === 'radial') return baseDir.clone();
                if (mode === 'wind-left') return new THREE.Vector3(-1, 0.2, 0).normalize();
                if (mode === 'wind-right') return new THREE.Vector3(1, 0.2, 0).normalize();
                return null;
            }

            // Foliage
            const foliageGroup = new THREE.Group(); treeGroup.add(foliageGroup);
            lastTerminalPieces = 0;
            function addTerminal(p, dir) {
                const grp = new THREE.Group();
                grp.position.copy(p);
                grp.lookAt(p.clone().add(dir));

                // Density: map [0..1] -> ~[4..22] with a gentle curve; cap globally
                const d = Math.max(0, Math.min(1.0, densityMul));
                const base = 4 + Math.round(18 * d * d); // quadratic easing; smaller at low d, ramps up smoothly
                let count = Math.min(base, MAX_GLOBAL_LEAVES - globalLeafCount);
                if (count <= 0) return;

                for (let i = 0; i < count; i++) {
                    const g = leafGeometry(leavesKind);
                    const meshOrGroup = (g.isGeometry || g.isBufferGeometry) ? new THREE.Mesh(g) : g;
                    meshOrGroup.userData.kind = (leavesKind === 'petal' ? 'petal' : 'leaf');

                    // Radial spread without geometry scaling (avoids squashing)
                    const rMax = 0.28 * leafSpreadMul;
                    const a = rr(r, 0, Math.PI * 2);
                    const rad = rr(r, 0.15 * leafSpreadMul, rMax);
                    const yJit = rr(r, -0.12, 0.12);
                    meshOrGroup.position.set(Math.cos(a) * rad, yJit, Math.sin(a) * rad);

                    // (keeping your random rotations)
                    if (meshOrGroup.rotation) {
                        meshOrGroup.rotation.set(rr(r, -0.2, 0.2), rr(r, -Math.PI, Math.PI), rr(r, -0.2, 0.2));
                    }

                    grp.add(meshOrGroup);
                    lastTerminalPieces++;
                    globalLeafCount++;             // <— increment global cap
                    if (globalLeafCount >= MAX_GLOBAL_LEAVES) break;
                }

                treeGroup.add(grp);
            }

            // Recursive branching
            function grow(origin, dirBase, levelIdx, depthLeft) {
                const pref = preferredDir(dirBase);
                const yaw = rr(r, -sp, sp) * Math.PI * 0.6 * (1 - uni);
                const pitch = rr(r, -0.2, 0.2) * Math.PI * 0.3 * (1 - uni) - rr(r, 0, up) * 0.2;
                let dir = dirBase.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw).applyAxisAngle(new THREE.Vector3(1, 0, 0), pitch);
                if (pref) { dir = dir.lerp(pref, uni).normalize(); } else dir.normalize();
                const L = branchLenMul * (2.6 * 0.45) * Math.pow(lenFall, levelIdx) * rr(r, 0.8, 1.2);
                const end = origin.clone().addScaledVector(dir, L);
                const t = Math.max(0.02, 0.07 * Math.pow(lenFall, levelIdx + 1));
                const seg = new THREE.Mesh(new THREE.BoxGeometry(t, t, L)); seg.userData.kind = 'branch';
                const q = new THREE.Quaternion(); q.setFromUnitVectors(new THREE.Vector3(0, 0, 1), dir);
                seg.quaternion.copy(q); seg.position.copy(origin.clone().addScaledVector(dir, L / 2));
                trunkGroup.add(seg); lastBranchSegments++;

                if (depthLeft <= 1) { addTerminal(end, dir); return; }
                // spawn children from this endpoint
                let n = Math.floor(rr(r, childMin, childMax + 1) * densityMul);
                if (PRESETS[treeType.value].branchPattern === 'whorl') { n = Math.max(3, Math.round(4 * densityMul)); }
                if (PRESETS[treeType.value].branchPattern === 'tiers') { n = Math.max(2, Math.round(3 * densityMul)); }
                n = Math.max(1, n);
                for (let k = 0; k < n; k++) {
                    // for whorls distribute yaw evenly
                    let dirChild = dir.clone();
                    if (PRESETS[treeType.value].branchPattern === 'whorl') {
                        const yawW = (k / n) * Math.PI * 2; dirChild.applyAxisAngle(new THREE.Vector3(0, 1, 0), yawW);
                    }
                    grow(end, dirChild, levelIdx + 1, depthLeft - 1);
                }
            }

            // Start recursive branching from last N trunk joints
            const jointsToUse = PRESETS[treeType.value].branchPattern === 'whorl' ? 5 : 3;
            const start = Math.max(1, pts.length - jointsToUse);
            for (let i = start; i < pts.length; i++) {
                const [a, b] = pts[i]; const dir = new THREE.Vector3().subVectors(b, a).normalize();
                // root fan of first-level branches from each joint
                let n0 = Math.max(1, Math.floor(rr(r, childMin, childMax + 1) * densityMul));
                if (PRESETS[treeType.value].branchPattern === 'whorl') { n0 = Math.max(3, Math.round(4 * densityMul)); }
                for (let m = 0; m < n0; m++) {
                    let d0 = dir.clone();
                    if (PRESETS[treeType.value].branchPattern === 'whorl') {
                        const yaw0 = (m / n0) * Math.PI * 2; d0.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw0);
                    }
                    grow(b, d0, i, depthBranches); // recursive depth
                }
            }

            applyRenderStyle();

            // --- keep camera EXACTLY the same (prevent tiny drift) ---
            const dampingWas = controls.enableDamping;
            const autoWas = (typeof controls.autoRotate === 'boolean') ? controls.autoRotate : false;
            const enabledWas = controls.enabled;
            const holdWas = holdSpin;

            holdSpin = 0;
            controls.enableDamping = false;
            controls.enabled = false;
            if (typeof controls.autoRotate === 'boolean') controls.autoRotate = false;

            // Restore camera transforms exactly
            camera.position.copy(camPos);
            controls.target.copy(camTarget);
            camera.updateProjectionMatrix();

            // Restore ike transform exactly (object stays where user left it)
            ike.position.copy(ikePos);
            ike.rotation.copy(ikeRot);
            ike.scale.copy(ikeScale);

            // Restore flags
            controls.enableDamping = dampingWas;
            controls.enabled = enabledWas;
            if (typeof controls.autoRotate === 'boolean') controls.autoRotate = autoWas;
            holdSpin = holdWas;
        }


        function applyVesselOnly() {
            makeVessel(vesselType.value, parseFloat(vesselDia.value), parseFloat(vesselDepth.value));
            updateSpinPivotFromVessel();
        }


        function savePNG() {
            const a = document.createElement('a'); a.download = `bonsai_${Date.now()}.png`; a.href = renderer.domElement.toDataURL('image/png'); a.click();
        }

        function tick() {
            const dt = clock.getDelta();
            applySpins(dt);          // << smooth spin is applied here
            controls.update();
            renderer.render(scene, camera);
            renderHUD();
            if (debugToggle && debugToggle.checked) {
                gizmo.visible = true;
                gizmo.position.copy(controls.target);
            } else {
                gizmo.visible = false;
            }


            requestAnimationFrame(tick);
        }

        // Bindings
        const bindLive = (el, fn) => { el.addEventListener('input', fn); el.addEventListener('change', fn); };
        [treeType, levels, curvature, uniformity, spread, upBias, bDepth, bMin, bMax, bLen, density, leafSpread, leafType, plumage].forEach(el => bindLive(el, regenerate));
        [wireToggle, renderMode].forEach(el => bindLive(el, applyRenderStyle));
        [vesselType, vesselDia, vesselDepth, vesselColor].forEach(el => bindLive(el, applyVesselOnly));
        [bgColor, bgTex].forEach(el => bindLive(el, applyBackground));
        keyLightUI.addEventListener('input', () => { dir.intensity = parseFloat(keyLightUI.value); });
        hemiLightUI.addEventListener('input', () => { hemi.intensity = parseFloat(hemiLightUI.value); });
        exposureUI.addEventListener('input', () => { renderer.toneMappingExposure = parseFloat(exposureUI.value); });
        emissiveStrengthUI.addEventListener('input', applyRenderStyle);

        // Left/Right: smooth while held; also pause auto when you touch them
        function onHold(dir, isDown) {
            setAutoRotate(false);
            holdSpin = isDown ? dir : 0;
        }
        // Left
        rotLeft.addEventListener('mousedown', () => onHold(+1, true));
        rotLeft.addEventListener('mouseup', () => onHold(+1, false));
        rotLeft.addEventListener('touchstart', (e) => { e.preventDefault(); onHold(+1, true); }, { passive: false });
        rotLeft.addEventListener('touchend', () => { onHold(+1, false); }, { passive: true });
        // Right
        rotRight.addEventListener('mousedown', () => onHold(-1, true));
        rotRight.addEventListener('mouseup', () => onHold(-1, false));
        rotRight.addEventListener('touchstart', (e) => { e.preventDefault(); onHold(-1, true); }, { passive: false });
        rotRight.addEventListener('touchend', () => { onHold(-1, false); }, { passive: true });

        // Play/Pause + speed
        autoBtn.addEventListener('click', () => setAutoRotate(!autoOn));
        if (autoSpeedUI) autoSpeedUI.addEventListener('input', () => {/* no-op: read live in tick() */ });
        if (autoRotate) autoRotate.addEventListener('change', () => setAutoRotate(autoRotate.value === 'on'));

        if (debugToggle) {
            debugToggle.addEventListener('change', () => {
                // no-op; renderHUD() pulls the state each frame
            });
        }
        // handy hotkey: backtick toggles HUD
        window.addEventListener('keydown', (e) => {
            if (e.key === '`') {
                if (debugToggle) debugToggle.checked = !debugToggle.checked;
            }
        });

        frameBtn.addEventListener('click', () => {
            const box = new THREE.Box3().setFromObject(ike);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());

            // Update orbit target to true center
            controls.target.copy(center);

            // Compute camera distance to fit object
            const maxDim = Math.max(size.x, size.y, size.z);
            const dist = maxDim / (2 * Math.tan(THREE.MathUtils.degToRad(camera.fov / 2))) + 2;

            // Move camera back along a fixed direction
            const viewDir = new THREE.Vector3(1, 0.6, 1).normalize();
            camera.position.copy(center).addScaledVector(viewDir, dist);
            camera.near = Math.max(0.01, dist * 0.02);
            camera.far = dist * 10;
            camera.updateProjectionMatrix();
            controls.update();
        });


        shotBtn.addEventListener('click', savePNG);
        newSeedBtn.addEventListener('click', () => { setSeed((Math.random() * 0xFFFFFFFF) >>> 0); regenerate(); });
        window.addEventListener('keydown', (e) => { if (e.code === 'Space') { e.preventDefault(); setSeed((Math.random() * 0xFFFFFFFF) >>> 0); regenerate(); } });

        // === Theme switching ===
        (() => {
            const app = document.getElementById('app');
            const themeSelect = document.getElementById('themeSelect');
            const modeCtrl = document.getElementById('modeControl');
            const segBtns = [...modeCtrl.querySelectorAll('.seg')];

            // --- helpers ---
            const setPressed = (val) => {
                segBtns.forEach(b => {
                    const on = b.dataset.mode === val;
                    b.setAttribute('aria-pressed', on ? 'true' : 'false');
                    b.classList.toggle('is-active', on);
                });
            };

            const setAccentAndMode = (accent, mode) => {
                if (accent) app.setAttribute('data-accent', accent);
                if (mode) app.setAttribute('data-mode', mode);

                // Compute --text-on-accent dynamically for readability on buttons
                requestAnimationFrame(() => {
                    const cs = getComputedStyle(app);
                    // Pick a mid-strong swatch to judge contrast
                    const bg = cs.getPropertyValue('--accent-600').trim() || '#888';

                    const rgb = bg.startsWith('#') ? hexToRgb(bg) : cssColorToRgb(bg);
                    const L = relLuminance(rgb.r, rgb.g, rgb.b);
                    // If accent is bright, use near-black text; if dark, use white.
                    const text = (L > 0.6) ? '#0b0f12' : '#ffffff';
                    app.style.setProperty('--text-on-accent', text);
                });

                // Persist
                localStorage.setItem('bonsai.accent', app.getAttribute('data-accent'));
                localStorage.setItem('bonsai.mode', app.getAttribute('data-mode'));
            };

            // luminance utilities
            function relLuminance(r, g, b) {
                const sRGB = [r, g, b].map(v => v / 255).map(v => v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4));
                return 0.2126 * sRGB[0] + 0.7152 * sRGB[1] + 0.0722 * sRGB[2];
            }
            function hexToRgb(h) {
                const m = h.replace('#', '');
                const v = (m.length === 3) ? m.split('').map(x => x + x).join('') : m;
                return { r: parseInt(v.slice(0, 2), 16), g: parseInt(v.slice(2, 4), 16), b: parseInt(v.slice(4, 6), 16) };
            }
            function cssColorToRgb(c) {
                // Handles rgb()/hsl() via a canvas trick
                const ctx = document.createElement('canvas').getContext('2d');
                ctx.fillStyle = c;
                const m = ctx.fillStyle; // normalized to rgb(a)
                const nums = m.match(/\d+(\.\d+)?/g).map(Number);
                return { r: nums[0], g: nums[1], b: nums[2] };
            }

            // --- events ---
            segBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const mode = btn.dataset.mode;
                    setPressed(mode);
                    setAccentAndMode(null, mode);
                });
            });

            themeSelect.addEventListener('change', () => {
                const accent = themeSelect.value;
                setAccentAndMode(accent, null);
            });

            // --- initial sync (from storage or existing attrs) ---
            const storedAccent = localStorage.getItem('bonsai.accent') || app.getAttribute('data-accent') || 'cyan';
            const storedMode = localStorage.getItem('bonsai.mode') || app.getAttribute('data-mode') || 'light';

            // reflect in UI
            themeSelect.value = storedAccent;
            setPressed(storedMode);
            setAccentAndMode(storedAccent, storedMode);
        })();

        function initial() {
            applyBackground();
            setSeed((Math.random() * 0xFFFFFFFF) >>> 0);
            regenerate();
            if (autoSpeedUI) { controls.autoRotateSpeed = parseFloat(autoSpeedUI.value); }
            setAutoRotate(true);
            frameBtn.click(); // ensures correct centering on first render
            tick();
            renderHUD();

        }

        initial();

        // Tests (console)
        (function tests() {
            const seedBefore = currentSeed;
            const camPos0 = camera.position.clone(); const tgt0 = controls.target.clone();
            treeType.value = 'pine'; regenerate(); console.assert(currentSeed === seedBefore, 'Seed changed when switching type');
            console.assert(camera.position.distanceTo(camPos0) < 1e-6 && controls.target.distanceTo(tgt0) < 1e-6, 'Camera moved on parameter change');

            // Start low, then increase (monotonic)
            bDepth.value = '1'; bLen.value = '0.7'; regenerate(); const segLow = lastBranchSegments; const tLow = lastTerminalPieces;
            bDepth.value = '3'; bLen.value = '1.0'; regenerate(); const segMid = lastBranchSegments; const tMid = lastTerminalPieces;
            bDepth.value = '4'; bLen.value = '1.6'; regenerate(); const segHigh = lastBranchSegments; const tHigh = lastTerminalPieces;
            console.assert(segMid > segLow && segHigh >= segMid, 'Branch depth/length did not increase segment count');
            console.assert(tMid > tLow && tHigh >= tMid, 'More depth did not increase terminals');

            const beforeBox = new THREE.Box3().setFromObject(ike).getSize(new THREE.Vector3()).x;
            leafSpread.value = '2.0'; regenerate();
            const afterBox = new THREE.Box3().setFromObject(ike).getSize(new THREE.Vector3()).x;
            console.assert(afterBox > beforeBox, 'Leaf spread did not widen silhouette');

            const exp0 = renderer.toneMappingExposure;
            exposureUI.value = String(exp0 * 1.5); renderer.toneMappingExposure = parseFloat(exposureUI.value); renderer.render(scene, camera);
            console.assert(renderer.toneMappingExposure > exp0, 'Exposure slider not applied');

            // Plumage upward should raise bbox height vs random (allow some variance)
            plumage.value = 'upward'; regenerate(); const hUp = new THREE.Box3().setFromObject(ike).getSize(new THREE.Vector3()).y;
            plumage.value = 'random'; regenerate(); const hRand = new THREE.Box3().setFromObject(ike).getSize(new THREE.Vector3()).y;
            console.assert(hUp >= hRand * 0.9, 'Plumage upward bias not applied');

            // Emissive intensity wiring
            renderMode.value = 'emissive'; applyRenderStyle();
            const before = parseFloat(emissiveStrengthUI.value);
            emissiveStrengthUI.value = String(before + 0.5); applyRenderStyle();
            let found = false; treeGroup.traverse(o => { if (o.isMesh && o.material.emissiveIntensity !== undefined) { found = true; } });
            console.assert(found, 'Emissive mode did not apply emissive materials');

            // Auto-rotate default ON and pause on manual nudge
            console.assert(controls.autoRotate === true, 'Auto-rotate should be ON by default');
            rotLeft.click(); console.assert(controls.autoRotate === false, 'Manual rotate should pause auto-rotate');

            // Reset
            leafSpread.value = '1.0'; bDepth.value = '3'; bLen.value = '1.0'; treeType.value = 'maple'; renderMode.value = 'toon'; wireToggle.value = 'off'; plumage.value = 'radial'; regenerate();
            console.info('%cTest cases passed', 'color:#9f9');
        })();

    </script>
</body>

</html>
